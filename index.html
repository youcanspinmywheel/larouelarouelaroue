<!DOCTYPE html>
<html lang="fr">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>YouCanSpinMyWheel</title>
  <link rel="icon" type="image/png" href="https://64.media.tumblr.com/8fde895ba7c7203d0638d3f842c60600/tumblr_inline_t63czilaK91yrz37b_500.png">
  
  <!-- Pr√©connexion au serveur d'images pour acc√©l√©rer le chargement -->
  <link rel="preconnect" href="https://64.media.tumblr.com">
  <link rel="dns-prefetch" href="https://64.media.tumblr.com">
</head>

<style>
  /* ========================================
     BASE & RESET
     ======================================== */
  html, body {
    height: 100%;
    overflow: hidden;
  }

  body {
    margin: 0;
    font-family: 'Courier New', monospace !important;
  }

  input:not([type="checkbox"]):not([type="range"]), 
  textarea,
  .wheel-option-name[contenteditable],
  .saved-wheel-name[contenteditable] {
    cursor: url('https://64.media.tumblr.com/3233d9c68709a4e2127c82d2a123fd31/tumblr_inline_t5l2vhPEqC1yrz37b_500.png') 32 32, auto;
  }

  input[type="checkbox"] {
    cursor: pointer;
  }

  /* Accessibilit√© : masquer visuellement mais garder pour les lecteurs d'√©cran */
  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }

  /* ========================================
     CLASSES UTILITAIRES
     ======================================== */
  /* Flexbox */
  .flex-center {
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .flex-column {
    display: flex;
    flex-direction: column;
  }

  /* Effets visuels */
  .btn-press-effect {
    transition: transform 0.1s ease;
  }

  .btn-press-effect:active {
    transform: scale(0.95);
  }

  .panel-glass {
    padding: 20px;
    border-radius: 12px;
    border: 4px solid rgba(255, 255, 255, 0.5);
    background: rgba(255, 255, 255, 0.3);
  }

  /* Boutons ronds fixes */
  .fixed-round-btn {
    position: fixed;
    width: 60px;
    height: 60px;
    background: rgba(255, 255, 255, 0.3);
    border: 3px solid rgba(255, 255, 255, 0.7);
    border-radius: 50%;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 28px;
    transition: all 0.3s ease;
  }

  .fixed-round-btn:hover {
    background: rgba(255, 255, 255, 0.5);
    transform: scale(1.1);
  }

  .fixed-round-btn:active {
    transform: scale(0.95);
  }

  /* Overlay */
  .overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.3);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.4s ease;
  }

  .overlay.active {
    opacity: 1;
    pointer-events: auto;
  }

  /* Zoom d'image */
  .image-zoom-container {
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .image-zoom-container img {
    width: 140%;
    height: 140%;
    object-fit: contain;
    display: block;
    transform: scale(1.4);
  }

  /* ========================================
     LAYOUT PRINCIPAL
     ======================================== */
  .app-layout {
    height: 100vh;
    padding: clamp(8px, 2vw, 24px) clamp(16px, 3vw, 40px);
    box-sizing: border-box;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    margin: auto;
    align-items: center;
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    background-attachment: fixed;
    transition: background-image 0.3s ease-in-out;
  }
  
  .app-layout.loading {
    background-color: #ff6b6b;
  }

  .main-content {
    display: flex;
    gap: 40px;
    width: 100%;
    max-width: 1980px;
    margin: 0 auto;
    height: 100%;
    align-items: center;
    justify-content: center;
    overflow: hidden;
  }

  /* Panneaux lat√©raux */
  .side-panel {
    height: fit-content;
    max-height: calc(100vh - 200px);
    margin: 0;
    padding: 20px;
    box-sizing: border-box;
    width: 350px;
    max-width: 350px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    scrollbar-width: none;
    -ms-overflow-style: none;
  }

  .side-panel::-webkit-scrollbar {
    display: none;
  }

  /* Panneau central */
  .main-panel {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: space-between;
    padding-top: 20px;
    padding-bottom: 40px;
    height: 100%;
  }

  /* ========================================
     BOUTONS FIXES & MENU MOBILE
     ======================================== */
  #mobile-menu-btn {
    display: none;
    top: 20px;
    left: 20px;
    z-index: 999;
  }

  #mobile-menu-overlay {
    display: none;
    z-index: 1998;
  }

  .fullscreen-btn {
    top: 20px;
    right: 20px;
    z-index: 1000;
    line-height: 1;
    padding: 0;
  }

  #note-tab {
    position: fixed;
    top: 90px;
    right: 20px;
    z-index: 1000;
    cursor: pointer;
    transition: transform 0.2s ease;
    background: transparent;
    border: #000;
  }

  #note-tab:hover {
    transform: scale(1.1);
  }

  #note-tab:active {
    transform: scale(0.95);
  }

  #note-tab img {
    width: 300px;
    height: auto;
    display: block;
  }

  /* ========================================
     RESPONSIVE DESIGN
     ======================================== */
  @media (min-width: 1600px) {
    #wheel-wrapper,
    .wheel-wrapper {
      width: 800px;
      height: 800px;
      max-width: min(90vw, 70vh);
      max-height: min(90vw, 70vh);
    }

    #needle,
    .needle {
      width: 280px;
      max-width: 40vw;
    }

    .button-spin-it {
      width: 320px;
      height: 130px;
    }

    .side-panel {
      width: 400px;
      max-width: 400px;
    }
  }

  @media (max-width: 1200px) {
    html, body {
      height: auto;
      min-height: 100%;
      overflow-x: hidden;
      overflow-y: auto;
    }

    .app-layout {
      height: auto;
      min-height: 100vh;
      overflow: visible;
    }

    .main-content {
      flex-direction: column;
    align-items: center;
      min-height: 100vh;
      height: auto;
      overflow: visible;
    }

    .main-panel {
      justify-content: flex-start;
      width: 100%;
      max-width: 100%;
      flex: 1;
    display: flex;
    flex-direction: column;
    }

    .right-panel {
      width: 100%;
      max-width: 600px;
    }

    #wheel-wrapper,
    .wheel-wrapper {
      width: min(85vw, 600px);
      height: min(85vw, 600px);
      margin: 0 auto;
      aspect-ratio: 1/1;
    }

    #needle,
    .needle {
      width: min(30vw, 220px);
    }

    #input-wrapper,
    .input-wrapper {
      margin-bottom: 20px;
    }

    #mobile-menu-btn {
      display: flex;
    }

    .left-panel {
      position: fixed;
      top: 0;
      left: -320px;
      width: 280px;
      height: 100vh;
      max-width: 280px;
      margin: 0;
      z-index: 1999;
      transition: left 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      overflow-y: auto;
      border-radius: 0;
      border-left: none;
      scrollbar-width: none; /* Firefox */
      -ms-overflow-style: none; /* IE et Edge */
    }

    .left-panel::-webkit-scrollbar {
      display: none; /* Chrome, Safari et Opera */
    }

    .left-panel.open {
      left: 0;
    }

    #mobile-menu-overlay {
      display: block;
    }

    #result {
      flex-direction: column;
      padding: 30px 30px;
      max-width: 85vw;
    }

    #result-text {
      padding: 0;
      margin-bottom: 15px;
      text-align: center;
    }

    .result-remove {
      margin-top: 10px;
      margin-left: 0;
      margin-right: 0;
    }
  }

  @media (max-width: 900px) {
    .wheel-title {
      max-width: 90vw;
      height: 140px;
    }

    #wheel-wrapper,
    .wheel-wrapper {
      width: min(85vw, 550px);
      height: min(85vw, 550px);
    }

    #needle,
    .needle {
      width: min(32vw, 200px);
    }
  }

  @media (max-width: 600px) {
    .wheel-title {
      max-width: 90vw;
      height: 100px;
    }

    #wheel-wrapper,
    .wheel-wrapper {
      width: min(90vw, 500px);
      height: min(90vw, 500px);
    }

    #needle,
    .needle {
      width: min(35vw, 180px);
    }
  }

  @media (max-width: 480px) {
    #wheel-wrapper,
    .wheel-wrapper {
      width: min(92vw, 450px);
      height: min(92vw, 450px);
    }

    #needle,
    .needle {
      width: min(38vw, 160px);
    }

    #result {
      flex-direction: column;
      padding: 25px 20px;
      max-width: 90vw;
    }

    #result-text {
      font-size: 1.5rem;
      margin-bottom: 20px;
    }

    .result-remove {
      margin-top: 15px;
    }
  }

  /* ========================================
     LISTES & ITEMS
     ======================================== */
  .wheel-list,
  .saved-wheels {
    display: flex;
    flex-direction: column;
    gap: 10px;
    padding: 0;
  }

  .wheel-options-list {
    max-height: 280px;
    overflow-y: auto;
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* IE et Edge */
  }

  .wheel-options-list::-webkit-scrollbar {
    display: none; /* Chrome, Safari et Opera */
  }

  .saved-wheels {
    max-height: 250px;
    overflow-y: auto;
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* IE et Edge */
  }

  .saved-wheels::-webkit-scrollbar {
    display: none; /* Chrome, Safari et Opera */
  }

  .wheel-list-item {
    display: flex;
    flex-direction: row;
    gap: 10px;
    align-items: center;
    justify-content: space-between;
    padding: 8px 0 8px 10px;
    border: 2px solid #fff;
    border-radius: 10px;
  }

  .saved-wheel {
    background: #edd4ff;
  } 

  .wheel-option-item {
    background: #ece9f9;
  }

  .saved-wheel-name,
  .wheel-option-name {
    font-size: 16px;
  }

  .saved-wheel-name {
    color: #fff;
    font-weight: 700;
  }

  .wheel-option-name {
    color: #000;
    font-weight: 400;
    word-break: break-word;
    white-space: normal;
    flex: 1;
  }

  .wheel-options-empty {
    display: none;
    margin-top: 10px;
    font-size: 14px;
    color: #333;
    text-align: center;
    opacity: 0.8;
  }

  /* ========================================
     BOUTONS D'ACTION
     ======================================== */
  .saved-wheel-actions {
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: space-around;
  }

  .saved-wheel-btn {
    cursor: pointer;
    background: none;
    padding: 0;
    border: none;
    width: 110px;
    height: 110px;
    transition: transform 0.1s ease;
  }

  .saved-wheel-btn img {
    width: 100%;
    height: 100%;
  }

  .saved-wheel-btn:active {
    transform: scale(0.9);
  }

  /* Tailles de boutons */
  .btn-little {
    width: 40px;
    height: 40px;
  }

  .saved-wheels .btn-little {
    width: 35px;
    height: 35px;
  }

  .left-panel .saved-wheel-actions {
    gap: 20px;
    justify-content: center;
  }

  .left-panel .saved-wheel-actions.saved-wheel-actions-little {
    gap: 5px;
  }

  .saved-wheel-actions-inner {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  /* ========================================
     MODAL R√âSULTAT & CONFETTIS
     ======================================== */
  #result {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0);
    background: rgba(255, 255, 255, 0.95);
    padding: 30px 50px;
    border: 4px solid #e2a9f1;
    border-radius: 20px;
    font-size: 2rem;
    font-weight: bold;
    color: #333;
    text-align: center;
    z-index: 2000;
    box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
    transition: transform 0.3s ease, opacity 0.3s ease;
    opacity: 0;
    pointer-events: auto;
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: center;
  }

  #result.show {
    transform: translate(-50%, -50%) scale(1);
    opacity: 1;
  }

  #result-text {
    padding: 0 20px;
  }

  .result-close {
    position: absolute;
    top: 12px;
    right: 12px;
    background: none;
    border: none;
    font-size: 20px;
    line-height: 1;
    cursor: pointer;
    color: #cb61a3;
    transition: transform 0.1s ease;
  }

  .result-close:active {
    transform: scale(0.85);
  }

  .result-remove {
    padding: 0;
    border: none;
    background: none;
    cursor: pointer;
    margin-left: auto;
    margin-right: auto;
    width: 100px;
    height: 80px;
    transition: transform 0.1s ease;
  }

  .result-remove img {
    width: 140%;
    height: 140%;
    object-fit: cover;
    display: block;
    transform: scale(1.4);
  }

  .result-remove:active {
    transform: scale(0.95);
  }

  /* Confettis */
  .confetti {
    position: fixed;
    width: 10px;
    height: 10px;
    background: #ff6b6b;
    top: -10px;
    z-index: 3000;
    pointer-events: none;
  }

  .confetti-animation {
    animation: confetti-fall linear forwards;
  }

  @keyframes confetti-fall {
    0% {
      transform: translateY(0) translateX(0) rotate(0deg);
      opacity: 1;
    }
    100% {
      transform: translateY(100vh) translateX(var(--drift)) rotate(720deg);
      opacity: 0;
    }
  }

  /* ========================================
     ROUE & √âL√âMENTS ASSOCI√âS
     ======================================== */
  .wheel-title {
    width: 100%;
    max-width: 900px;
    /* height: 200px; */
    margin: 0 auto 20px auto;
  }

  #wheel-wrapper,
  .wheel-wrapper {
    position: relative;
    width: 600px;
    height: 600px;
    max-width: min(90vw, 55vh);
    max-height: min(90vw, 55vh);
    margin: auto;
    display: flex;
    align-items: center;
    justify-content: center;
    aspect-ratio: 1/1;
  }

  #wheel,
  .wheel {
    display: block;
    width: 100%;
    height: 100%;
  }

  #needle,
  .needle {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 220px;
    max-width: 35vw;
    height: auto;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: none;
    z-index: 10;
  }

  #needle img,
  .needle img {
    width: 100%;
    height: auto;
    display: block;
  }

  /* ========================================
     INPUTS & CONTR√îLES
     ======================================== */
  #input-wrapper,
  .input-wrapper {
    margin-bottom: 20px;
    display: flex;
    gap: 15px;
    align-items: center;
    justify-content: center;
    width: 100%;
    flex-direction: column;
  }

  .entry-input {
    height: 40px;
    width: 100%;
    text-align: center;
    padding: 1em;
    border: 1px solid #ddd;
    border-radius: 8px;
    font-size: 0.9rem;
  }

  .button-spin-it {
    width: 250px;
    height: 100px;
    border: none;
    padding: 0;
    background-color: transparent;
    background-image: url('https://64.media.tumblr.com/64198fdc8c43db55b21af0e3231627fd/tumblr_inline_t5sp2rucFY1yrz37b_500.png');
    background-size: 180% auto;
    background-repeat: no-repeat;
    background-position: center;
    cursor: url('https://64.media.tumblr.com/21fd2e9d16129f8aa472613f22ffd995/tumblr_inline_t5otmmxVV01yrz37b_500.png') 32 32, auto;
    margin: 20px auto 0 auto;
    display: block;
    transition: transform 0.1s ease;
  }

  .button-spin-it:active:not(:disabled) {
    transform: scale(0.95);
  }

  .button-spin-it:disabled {
    filter: grayscale(1) brightness(0.8);
    cursor: not-allowed;
  }

  .wheel-option-checkbox {
    width: 20px;
    height: 20px;
  }

  .wheel-option-checkbox-label {
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .wheel-option-checkbox-label img {
    width: 40px;
    height: 40px;
  }

  /* ========================================
     SLIDER SUSPENSE
     ======================================== */
  .suspense-slider-container {
    padding: 15px;
    margin-bottom: 10px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 8px;
  }

  .suspense-label {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
    font-weight: bold;
    font-size: 14px;
  }

  .suspense-slider {
    width: 100%;
    height: 8px;
    border-radius: 5px;
    background: rgba(255, 255, 255, 0.3);
    outline: none;
    cursor: pointer;
  }
  
  #suspense-value {
    font-weight: bold;
    font-size: 16px;
  }

  /* ========================================
     MODAL DE CONFIRMATION
     ======================================== */
  .modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.7);
    backdrop-filter: blur(4px);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
  }

  .modal-overlay.show {
    opacity: 1;
    pointer-events: auto;
  }

  .modal-content {
    background: rgba(255, 255, 255, 0.95);
    padding: 35px;
    border-radius: 20px;
    border: 4px solid #e2a9f1;
    max-width: 450px;
    width: 90%;
    text-align: center;
    box-shadow: 0 8px 30px rgba(203, 97, 163, 0.4);
    transform: scale(0.9);
    transition: transform 0.3s ease;
  }

  .modal-overlay.show .modal-content {
    transform: scale(1);
  }

  .modal-title {
    margin: 0 0 15px 0;
    font-size: 22px;
    color: #f27a96;
    font-weight: bold;
  }

  .modal-message {
    margin: 0 0 30px 0;
    font-size: 16px;
    color: #333;
    line-height: 1.6;
  }

  .modal-buttons {
    display: flex;
    gap: 12px;
    justify-content: center;
    flex-wrap: wrap;
  }

  .modal-btn {
    padding: 12px 24px;
    border: 2px solid transparent;
    border-radius: 10px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
    transition: all 0.2s ease;
    min-width: 130px;
  }

  .modal-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
  }

  .modal-btn:active {
    transform: scale(0.95);
  }

  .modal-btn-save {
    background: #e2a9f1;
    color: white;
    border-color: #e2a9f1;
  }

  .modal-btn-save:hover {
    background: #efb3ff;
    border-color: #efb3ff;
  }

  .modal-btn-discard {
    background: #f496ad;
    color: white;
    border-color: #f496ad;
  }

  .modal-btn-discard:hover {
    background: #ffb7c8;
    border-color: #ffb7c8;
  }

  .modal-btn-cancel {
    background: rgba(255, 255, 255, 0.9);
    color: #f5d4fb;
    border-color: #f5d4fb;
  }

  .modal-btn-cancel:hover {
    background: #f5d4fb;
    color: white;
  }

  /* ========================================
     PANEL NOTES
     ======================================== */
  #side-note-overlay {
    z-index: 1999;
    transition: opacity 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  }

  #side-note {
    position: fixed;
    top: 0;
    right: 0;
    width: 400px;
    max-width: 90vw;
    height: 100vh;
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    z-index: 2000;
    overflow-y: auto;
    transform: translateX(100%);
    transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: -4px 0 20px rgba(0, 0, 0, 0.2);
    color: #f496ad;
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* IE et Edge */
  }

  #side-note::-webkit-scrollbar {
    display: none; /* Chrome, Safari et Opera */
  }

  #side-note.open {
    transform: translateX(0);
  }

  #side-note-close {
    position: absolute;
    top: 15px;
    right: 15px;
    background: none;
    border: none;
    font-size: 24px;
    color: #f496ad;
    cursor: pointer;
    z-index: 2001;
    transition: transform 0.1s ease;
  }

  #side-note-close:active {
    transform: scale(0.85);
  }

  .note-content {
    padding: 50px 20px 30px 20px;
    color: #f496ad;
  }

  .compact-intro {
    margin-bottom: 25px;
    font-size: 14px;
    line-height: 1.6;
  }

  .info-item {
    margin-bottom: 10px;
    background: rgba(244, 150, 173, 0.1);
    border-radius: 8px;
    overflow: hidden;
    transition: background 0.2s ease;
  }

  .info-item summary {
    padding: 12px;
    cursor: pointer;
    font-size: 14px;
    font-weight: bold;
    list-style: none;
    transition: background 0.2s ease;
    user-select: none;
  }

  .info-item summary::-webkit-details-marker {
    display: none;
  }

  .info-item summary::marker {
    display: none;
  }

  .info-item summary::before {
    content: '‚ñº';
    float: right;
    font-size: 12px;
    transition: transform 0.3s ease;
  }

  .info-item[open] summary::before {
    transform: rotate(180deg);
  }

  .info-item summary:hover {
    background: rgba(244, 150, 173, 0.2);
  }

  .info-item-text {
    padding: 12px;
    font-size: 13px;
    line-height: 1.6;
    font-weight: normal;
  }

  .info-item-img {
    padding: 0 12px 12px 12px;
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
  }

  .info-item-img img {
    max-width: 80px;
    height: auto;
    border-radius: 4px;
  }

  /* ========================================
     MODE PLEIN √âCRAN
     ======================================== */
  .fullscreen-mode .main-content {
    flex-direction: row;
  }

  .fullscreen-mode .left-panel,
  .fullscreen-mode .right-panel,
  .fullscreen-mode .wheel-title {
    display: none !important;
  }

  .fullscreen-mode .main-panel {
    width: 100%;
    max-width: 100%;
    padding-bottom: 40px;
  }

  .fullscreen-mode .fullscreen-btn {
    background: rgba(255, 255, 255, 0.5);
  }

  .fullscreen-mode #wheel-wrapper,
  .fullscreen-mode .wheel-wrapper {
    width: min(75vh, 75vw);
    height: min(75vh, 75vw);
    max-width: 1000px;
    max-height: 1000px;
    aspect-ratio: 1/1;
  }

  .fullscreen-mode #needle,
  .fullscreen-mode .needle {
    width: 240px;
  }

  .fullscreen-mode .button-spin-it {
    width: 300px;
    height: 120px;
    margin-top: 30px;
  }

</style>

<body>
  <!-- Layout principal -->
  <div class="app-layout">
    
    <!-- Boutons fixes -->
    <button class="fullscreen-btn fixed-round-btn" id="fullscreen-toggle" title="Mode plein √©cran" aria-label="Mode plein √©cran">
      ‚õ∂
              </button>
    <button id="mobile-menu-btn" class="fixed-round-btn" title="Menu" aria-label="Menu mobile">
      ‚ò∞
    </button>
    <div id="mobile-menu-overlay" class="overlay" aria-hidden="true"></div>

    <!-- Contenu principal -->
    <main class="main-content">
      
      <!-- Panneau gauche : Roues sauvegard√©es -->
      <aside class="left-panel side-panel panel-glass" aria-label="Roues sauvegard√©es">
        <!-- Liste des roues sauvegard√©es -->
        <ul class="saved-wheels" role="list">
          <!-- Template pour les roues sauvegard√©es -->
          <li class="wheel-list-item saved-wheel" role="listitem">
            <span class="saved-wheel-name" contenteditable="plaintext-only" aria-label="Nom de la roue">Roue</span>
            <div class="saved-wheel-actions saved-wheel-actions-little">
              <button class="saved-wheel-btn btn-little" aria-label="Charger cette roue" title="Charger">
                <img src="https://64.media.tumblr.com/38b4d4957a4e7549d77ce2bb1f7c0e90/tumblr_inline_t5sk5ubmue1yrz37b_500.png" alt="">
              </button>
              <button class="saved-wheel-btn btn-little" aria-label="Supprimer cette roue" title="Supprimer">
                <img src="https://64.media.tumblr.com/ac01b9159b656988427fdbb5352358d9/tumblr_inline_t5sk1yXcQZ1yrz37b_500.png" alt="">
              </button>
            </div>
          </li>
        </ul>

        <!-- Actions principales -->
        <div class="saved-wheel-actions">
          <button id="save-wheel" class="saved-wheel-btn" aria-label="Sauvegarder la roue" title="Sauvegarder">
            <img src="https://64.media.tumblr.com/afc7261aa22a5dcb76c8f6e31b864321/tumblr_inline_t5mtd4dvBq1yrz37b_500.png" alt="">
          </button>
          <button id="add-new-wheel" class="saved-wheel-btn" aria-label="Cr√©er une nouvelle roue" title="Nouvelle roue">
            <img src="https://64.media.tumblr.com/009bdd2056921bb140c3696166e34087/tumblr_inline_t5mtb5ElNI1yrz37b_500.png" alt="">
          </button>
        </div>

        <!-- Import/Export -->
        <div class="saved-wheel-actions">
          <button id="import-wheel" class="saved-wheel-btn" aria-label="Importer une roue" title="Importer">
            <img src="https://64.media.tumblr.com/4e4231d7ce48692de21de432886874e8/tumblr_inline_t6706e4mNx1yrz37b_500.png" alt="">
          </button>
          <button id="export-wheel" class="saved-wheel-btn" aria-label="Exporter la roue" title="Exporter">
            <img src="https://64.media.tumblr.com/f57fd4198e33cccbe513cdf2840d8e47/tumblr_inline_t670880F1W1yrz37b_500.png" alt="">
          </button>
        </div>
      </aside>

      <!-- Panneau central : La roue -->
      <section class="main-panel" aria-label="Roue principale">
        
        <!-- Titre de la roue -->
        <div class="wheel-title image-zoom-container" role="img" aria-label="Titre de la roue"></div>

        <!-- La roue et l'aiguille -->
        <div id="wheel-wrapper" class="wheel-wrapper" role="img" aria-label="Roue de la fortune">
          <div id="needle" class="needle" aria-hidden="true">
            <img src="https://64.media.tumblr.com/4822cf2aace6f4c1529326c5018b4795/tumblr_inline_t5qpt4qUqZ1yrz37b_500.png" alt="">
        </div>
          <canvas id="wheel" class="wheel" aria-label="Canvas de la roue"></canvas>
        </div>

        <!-- Bouton Spin -->
        <button id="spin" class="button-spin-it" aria-label="Faire tourner la roue" title="Spin!"></button>
      </section>

      <!-- Panneau droit : Options -->
      <aside class="side-panel right-panel panel-glass" aria-label="Options de la roue">
        
        <!-- Input pour ajouter des options -->
        <div id="input-wrapper" class="input-wrapper">
          <label for="entry-input" class="sr-only">Ajouter une option</label>
          <input 
            id="entry-input" 
            type="text" 
            class="entry-input" 
            placeholder="Ajoutes des DRAMAAAS & appuie sur Entr√©e"
            aria-label="Ajouter une option √† la roue"
          />
      </div>

        <!-- Slider de suspense -->
        <div id="suspense-slider-container" class="suspense-slider-container" style="display: none;" role="group" aria-labelledby="suspense-label">
          <label for="suspense-slider" class="suspense-label" id="suspense-label">
            Suspense: <span id="suspense-value" aria-live="polite">x1</span>
          </label>
          <input 
            type="range" 
            id="suspense-slider" 
            class="suspense-slider" 
            min="1" 
            max="5" 
            value="1" 
            step="1"
            aria-label="Niveau de suspense"
          />
        </div>

        <!-- Liste des options -->
        <ul class="wheel-list wheel-options-list" role="list">
          <!-- Template pour les options -->
          <li class="wheel-list-item wheel-option-item" role="listitem">
            <span class="wheel-option-name" contenteditable="plaintext-only" aria-label="Nom de l'option">Toto</span>
            <div class="saved-wheel-actions">
              <div class="saved-wheel-actions-inner">
                <input 
                  id="wheel-option-checkbox-booster" 
                  type="checkbox" 
                  class="wheel-option-checkbox"
                  aria-label="Activer le booster pour cette option"
                />
                <label for="wheel-option-checkbox-booster" class="wheel-option-checkbox-label">
                  <img src="https://64.media.tumblr.com/87a0653bca17c9e30e393dccbf5745c0/tumblr_inline_t5rsbldLa31yrz37b_1280.png" alt="x2"> 
                  x2
                </label>
              </div>
              <button class="saved-wheel-btn btn-little" aria-label="Supprimer cette option" title="Supprimer">
                <img src="https://64.media.tumblr.com/ac01b9159b656988427fdbb5352358d9/tumblr_inline_t5sk1yXcQZ1yrz37b_500.png" alt="Supprimer">
              </button>
            </div>
          </li>
        </ul>

        <!-- Message quand la liste est vide -->
        <div class="wheel-options-empty" id="wheel-options-empty" role="status" aria-live="polite">
          Mmmmh, √ßa manque de dramas par ici...
      </div>
      </aside>
    </main>
    <!-- Modal de r√©sultat -->
    <div id="result" role="dialog" aria-modal="true" aria-labelledby="result-text">
      <button id="result-close" class="result-close" aria-label="Fermer le r√©sultat" title="Fermer">
        ‚úï
      </button>
      <div id="result-text" role="status" aria-live="assertive"></div>
      <button id="result-remove" class="result-remove image-zoom-container btn-press-effect" aria-label="Retirer cette option de la roue" title="Retirer">
        <img src="https://64.media.tumblr.com/cac9ba854a3a4b59b7c706f9217da9eb/tumblr_inline_t66rgcSOSm1yrz37b_500.png" alt="">
      </button>
    </div>

    <!-- Modal de confirmation (modifications non sauvegard√©es) -->
    <div id="unsaved-changes-modal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="unsaved-modal-title" style="display: none;">
      <div class="modal-content">
        <h3 id="unsaved-modal-title" class="modal-title">Modifications non sauvegard√©es</h3>
        <p class="modal-message">Voulez-vous vraiment ne pas sauvegarder les modifications ?</p>
        <div class="modal-buttons">
          <button id="modal-save-btn" class="modal-btn modal-btn-save">Sauvegarder</button>
          <button id="modal-discard-btn" class="modal-btn modal-btn-discard">Ne pas sauvegarder</button>
          <button id="modal-cancel-btn" class="modal-btn modal-btn-cancel">Annuler</button>
  </div>
      </div>
    </div>
  </div>

  <!-- Bouton d'ouverture du panneau d'informations -->
  <button id="note-tab" aria-label="Ouvrir le panneau d'informations" title="Informations">
    <img src="https://64.media.tumblr.com/79f689347e6c5ebf5b20957984b9260b/tumblr_inline_t5ubhgt1UJ1yrz37b_500.png" alt="">
  </button>

  <!-- Panneau d'informations -->
  <div id="side-note-overlay" class="overlay" aria-hidden="true"></div>
  <aside id="side-note" role="complementary" aria-label="Informations et aide">
    <button id="side-note-close" aria-label="Fermer le panneau d'informations" title="Fermer">
      ‚úï
    </button>
    <div class="note-content">
      <div class="compact-info">

               <!-- Introduction -->
        <div class="compact-intro">
            Les P√™ches aiment les <strong>DRAMAS</strong>. Les P√™ches aiment les <strong>ROUES</strong>. Et comme tu es notre <strong>Kween</strong>, on a d√©cid√©, pour cette nouvelle √©dition du Kalendrier, de te cr√©er un mini-site qui m√©lange les deux !
            <br>
            <br>Avec amour,
            <br>
            <strong>MylittleponyOh, Gawi√®ne & les P√™ches ‚ú®</strong>
          <br>
        </div>

        <!-- Sections d'information -->
        <details class="info-item">
          <summary>üñãÔ∏è LES DRAMAS</summary>
          <div class="info-item-text">
            Chaque input (ou plut√¥t chaque DRAMA) est enti√®rement modifiable et supprimable √† tout moment. Chaque entr√©e est prise en compte une seule fois dans le tirage‚Ä¶ sauf si tu d√©cides de <s>tricher</s> "spice it up".
        </div>
        </details>

        <details class="info-item">
          <summary>üå°Ô∏è LE CHEATCODE "C'est un jeu dangereux"</summary>
          <div class="info-item-text">
Tu veux qu‚Äôun drama ait plus d‚Äôimpact dans le tirage ? Coche la case CHEATCODE pour lui donner x2 plus de chance d'√™tre tir√© au sort. Non non‚Ä¶ ce n‚Äôest pas de la triche, c‚Äôest de la ‚ú®strat√©gie.‚ú®        </div>
          <div class="info-item-img">
            <img src="https://64.media.tumblr.com/87a0653bca17c9e30e393dccbf5745c0/tumblr_inline_t5rsbldLa31yrz37b_500.png" alt="Ic√¥ne Cheatcode">
        </div>
        </details>
        
        <details class="info-item">
          <summary>‚ö°Ô∏è LE SLIDER "Suspense"</summary>
          <div class="info-item-text">
            <strong>Quand on veut des Dramas, le suspense est toujours l√† !</strong>
            <br>Ajuste le slider pour que chaque drama de ta liste soit multipli√© jusqu‚Äô√† 5 fois. Chaotiques, nous ? 
        </div>
        </details>

        <details class="info-item">
          <summary>üíæ LE SYSTEME DE SAUVEGARDE</summary>
          <div class="info-item-text">
            Fini les roues perdues dans la nature : m√™me si tu fermes la page, tu retrouveras toutes tes sauvegardes. Tu peux charger, renommer ou supprimer tes roues √† tout moment. 
        </div>
          <div class="info-item-img">
            <img src="https://64.media.tumblr.com/afc7261aa22a5dcb76c8f6e31b864321/tumblr_inline_t5mtd4dvBq1yrz37b_500.png" alt="Ic√¥ne Sauvegarder">
            <img src="https://64.media.tumblr.com/38b4d4957a4e7549d77ce2bb1f7c0e90/tumblr_inline_t5sk5ubmue1yrz37b_500.png" alt="Ic√¥ne Charger">
            <img src="https://64.media.tumblr.com/ac01b9159b656988427fdbb5352358d9/tumblr_inline_t5sk1yXcQZ1yrz37b_500.png" alt="Ic√¥ne Supprimer">
          </div>
        </details>
        
        <details class="info-item">
          <summary>‚ÜïÔ∏è IMPORTE & EXPORTE TES ROUES</summary>
          <div class="info-item-text">
            Comme on est dans le partage, on s'est dit qu'importer ou exporter des roues faites par nos jolies <strong>P√™ches</strong> √ßa pouvait √™tre vraiment chouette. Alors on l'a ajout√©. 
            <br>
            <br><strong>Exporter</strong>
            <br> Choisis la roue √† exporter (soit la roue actuelle, ou charge une roue sauvegard√©e ).
            <br><strong>1.</strong> Clique sur <strong>Export A Wheel</strong> (le texte est automatiquement copi√© dans ton presse-papier).
            <br><strong>2.</strong>Partage le √† la P√™che de ton choix. 
            <br>
            <br><strong>Importer</strong>
            <br><strong>1.</strong> Copie le texte qu'on t'a envoy√© (le texte est maintenant dans ton presse-papier)
            <br><strong>2.</strong>Clique sur <strong>Import a wheel</strong>.
            <br><strong>3.</strong>La nouvelle roue est import√©e dans ta liste de roues & elle est pr√™te √† tourner ! 
        </div>
          <div class="info-item-img">
            <img src="https://64.media.tumblr.com/0f33cc93302175124ed38bac5fc1c588/tumblr_inline_t66riw7dCj1yrz37b_500.png" alt="Ic√¥ne Importer">
            <img src="https://64.media.tumblr.com/d2e9593ed01f463308c8bfd5f4f424d6/tumblr_inline_t66ri1LrnJ1yrz37b_500.png" alt="Ic√¥ne Exporter">
          </div>
        </details>

        <details class="info-item">
          <summary>‚ò∏Ô∏è SPIN IT !!!</summary>
          <div class="info-item-text">
            Fais tourner la roue autant de fois que tu veux et ajoute de nouveaux inputs m√™me apr√®s un spin.
        </div>
        </details>

      </div>
    </div>
  </aside>

  <script>
    'use strict';

    // ========================================
    // CONSTANTES
    // ========================================
    const STORAGE_KEYS = {
      SAVED_WHEELS: 'toto-saved-wheels',
      LAST_BACKGROUND: 'wheel-last-background',
      LAST_TITLE: 'wheel-last-title',
      UNSAVED_STATE: 'wheel-unsaved-state'
    };

    const WHEEL_CONFIG = {
      COLORS: [
        '#ece9f9', '#ddd8f0', '#fde4cf', '#ffcfd2', '#f1c0e8', '#cfbaf0',
        '#a3c4f3', '#90dbf4', '#8eecf5', '#98f5e1', '#b9fbc0'
      ],
      ROTATION_SPEED: 0.002,
      SPIN_DURATION: 3000,
      MIN_EXTRA_SPINS: 4,
      MAX_EXTRA_SPINS: 7,
      TICK_SOUND_URL: 'https://64.media.tumblr.com/1c742fbe5dbe55a09b2958c4170ec774/30cee4da24efc2ee-a4/dd9127efe62e3f4c93a46962fda5bcd434d92155.mp3',
      TICK_SOUND_VOLUME: 0.3
    };

    const ANIMATION_CONFIG = {
      CONFETTI_COUNT: 150,
      CONFETTI_COLORS: ['#ff6b6b', '#4ecdc4', '#ffe66d', '#95e1d3', '#f38181', '#aa96da', '#fcbad3', '#a8e6cf']
    };

    // ========================================
    // UTILITAIRES
    // ========================================
    const Utils = {
      /**
       * Normalise une option en objet
       */
      normalizeOption(opt) {
        if (typeof opt === 'string') {
          return { text: opt, boosted: false, multiplier: 1 };
        }
        return {
          text: opt.text,
          boosted: !!opt.boosted,
          multiplier: opt.multiplier && opt.multiplier > 0 ? opt.multiplier : 1
        };
      },

      /**
       * G√©n√®re un ID unique
       */
      generateId() {
        return `wheel-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      },

      /**
       * Gestion s√©curis√©e du localStorage
       */
      storage: {
        get(key, defaultValue = null) {
          try {
            const item = localStorage.getItem(key);
            return item ? JSON.parse(item) : defaultValue;
          } catch (e) {
            console.error(`Erreur lors de la lecture de ${key}:`, e);
            return defaultValue;
          }
        },

        set(key, value) {
          try {
            localStorage.setItem(key, JSON.stringify(value));
            return true;
          } catch (e) {
            console.error(`Erreur lors de l'√©criture de ${key}:`, e);
            return false;
          }
        },

        getString(key, defaultValue = null) {
          try {
            return localStorage.getItem(key) || defaultValue;
          } catch (e) {
            console.error(`Erreur lors de la lecture de ${key}:`, e);
            return defaultValue;
          }
        },

        setString(key, value) {
          try {
            localStorage.setItem(key, value);
            return true;
          } catch (e) {
            console.error(`Erreur lors de l'√©criture de ${key}:`, e);
            return false;
          }
        }
      }
    };

    // ========================================
    // CLASSE WHEEL
    // ========================================
    class Wheel {
      /**
       * @param {HTMLCanvasElement} canvas
       * @param {Array<string|{text:string}>} options
       */
      constructor(canvas, options = [], useAsDefaults = false) {
        if (!canvas || !canvas.getContext) {
          throw new Error('Canvas invalide fourni au constructeur Wheel');
        }

        // Canvas et contexte
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        
        // Configuration visuelle
        this.colors = WHEEL_CONFIG.COLORS;
        this.centerX = this.canvas.width / 2;
        this.centerY = this.canvas.height / 2;
        const maxRadius = Math.min(this.centerX, this.centerY);
        this.outsideRadius = maxRadius - 15;
        this.insideRadius = Math.max(25, this.outsideRadius * 0.15);

        // Options
        this.options = (options || []).map(Utils.normalizeOption);
        this.baseOptions = [];
        this.defaultOptions = useAsDefaults ? this.options.map(opt => ({ ...opt })) : [];
        this.usesDefaultOptions = !!useAsDefaults;

        // Animation et rotation
        this.rotationAngle = 0;
        this.rotationSpeed = WHEEL_CONFIG.ROTATION_SPEED;
        this.isAutoRotating = false;
        this.isSpinning = false;
        this.rainbowTime = 0;

        // Audio
        this.tickSound = new Audio(WHEEL_CONFIG.TICK_SOUND_URL);
        this.tickSound.volume = WHEEL_CONFIG.TICK_SOUND_VOLUME;
        this.lastSegmentIndex = -1;

        // Callbacks et √©tat
        this.onSpinEnd = null;
        this.onOptionsChanged = null;
        this.lastWinnerIndex = null;

        // DOM
        this.optionsListElement = null;
        this.optionItemTemplate = null;
        this.emptyMessageElement = null;

        // Suspense
        this.suspenseMultiplier = 1;
      }

      /**
       * R√©initialise la roue sur ses valeurs par d√©faut (D R A M A S).
       */
      resetToDefault() {
        if (!this.defaultOptions.length) return;
        this.options = this.defaultOptions.map((opt) => ({ ...opt }));
        this.usesDefaultOptions = true;
        this.draw();
        this.updateOptionsList();
        this.notifyOptionsChanged();
      }

      setOptions(options) {
        this.baseOptions = (options || []).map(Utils.normalizeOption);
        this.applySuspenseMultiplier();
      }
      
      /**
       * Applique le multiplicateur de suspense en dupliquant les options
       */
      applySuspenseMultiplier() {
        if (this.suspenseMultiplier <= 1) {
          this.options = this.baseOptions.map(opt => ({ ...opt }));
        } else {
          this.options = [];
          for (let i = 0; i < this.suspenseMultiplier; i++) {
            this.baseOptions.forEach(opt => {
              this.options.push({ ...opt });
            });
          }
        }
        this.draw();
        this.updateOptionsList();
        this.notifyOptionsChanged();
      }
      
      /**
       * Modifie le multiplicateur de suspense
       */
      setSuspenseMultiplier(multiplier) {
        this.suspenseMultiplier = Math.max(1, Math.min(5, parseInt(multiplier) || 1));
        this.applySuspenseMultiplier();
      }

      /**
       * Ajoute une option. Lors du premier ajout, on supprime les valeurs par d√©faut.
       */
      addOption(optionLabel) {
        const value = String(optionLabel || '').trim();
        if (!value) return;

        if (this.usesDefaultOptions) {
          this.baseOptions = [];
          this.usesDefaultOptions = false;
        }

        this.baseOptions.push({ text: value, boosted: false, multiplier: 1 });
        this.applySuspenseMultiplier();
      }

      /**
       * Supprime une option par index (pour √™tre align√© avec le style de script.js).
       */
      removeOption(index) {
        // Trouver l'index dans baseOptions (diviser par suspenseMultiplier)
        const baseIndex = Math.floor(index / this.suspenseMultiplier);
        if (baseIndex < 0 || baseIndex >= this.baseOptions.length) return;
        
        this.baseOptions.splice(baseIndex, 1);
        
        // Si tout a √©t√© supprim√© et qu'on a des valeurs par d√©faut, on les restaure
        if (!this.baseOptions.length && this.defaultOptions.length) {
          this.baseOptions = this.defaultOptions.map((opt) => ({ ...opt }));
          this.usesDefaultOptions = true;
        }
        
        this.applySuspenseMultiplier();
      }

      /**
       * Attache la liste DOM (ul.wheel-options-list) pour refl√©ter les options.
       */
      attachOptionsList(element) {
        this.optionsListElement = element;
        // On m√©morise un template √† partir du premier item existant
        if (!this.optionItemTemplate) {
          const existingItem = element.querySelector('.wheel-option-item');
          if (existingItem) {
            this.optionItemTemplate = existingItem.cloneNode(true);
          }
        }
        // On r√©cup√®re l'√©l√©ment de message (en dehors de la liste)
        if (!this.emptyMessageElement && element.parentElement) {
          this.emptyMessageElement = element.parentElement.querySelector('.wheel-options-empty');
        }
        // On vide la liste pour repartir proprement : tout sera r√©g√©n√©r√©
        this.optionsListElement.innerHTML = '';
        this.updateOptionsList();
      }

      /**
       * Notifie l'UI que les options ont chang√© (pour, par ex., activer/d√©sactiver le bouton SPIN).
       */
      notifyOptionsChanged() {
        if (typeof this.onOptionsChanged === 'function') {
          this.onOptionsChanged(this);
        }
      }
      
      /**
       * G√®re l'affichage du slider de suspense
       */
      updateSuspenseSliderVisibility() {
        const sliderContainer = document.getElementById('suspense-slider-container');
        if (sliderContainer) {
          // Afficher le slider seulement si on a au moins 2 options de base et qu'on n'est pas en mode default
          const shouldShow = !this.usesDefaultOptions && this.baseOptions.length >= 2;
          sliderContainer.style.display = shouldShow ? 'block' : 'none';
        }
      }

      /**
       * Met √† jour le panneau de droite (wheel-option-item) √† partir des options.
       */
      updateOptionsList() {
        if (!this.optionsListElement) return;

        const list = this.optionsListElement;
        list.innerHTML = '';

        // Si on n'a pas r√©ussi √† r√©cup√©rer un template, on ne fait rien
        if (!this.optionItemTemplate) {
          return;
        }

        const isDefaultState = this.usesDefaultOptions && this.defaultOptions.length;

        // Affichage / masquage du message HTML d√©di√©
        if (this.emptyMessageElement) {
          this.emptyMessageElement.style.display = isDefaultState ? 'block' : 'none';
        }

        // En √©tat par d√©faut, on n'affiche aucune option dans la liste
        if (isDefaultState) {
          return;
        }

        // Afficher uniquement les options de base (pas les duplicatas)
        this.baseOptions.forEach((opt, index) => {
          // On clone simplement le <li> template
          const li = this.optionItemTemplate.cloneNode(true);

          const nameSpan = li.querySelector('.wheel-option-name');
          if (nameSpan) {
            nameSpan.textContent = opt && opt.text ? opt.text : '';
            
            // Rendre l'option √©ditable
            nameSpan.setAttribute('contenteditable', 'plaintext-only');
            
            // Sauvegarder les modifications lors de l'√©dition
            nameSpan.addEventListener('blur', () => {
              const newText = nameSpan.textContent.trim();
              if (newText && newText !== opt.text) {
                opt.text = newText;
                this.applySuspenseMultiplier();
              } else if (!newText) {
                // Si vide, restaurer l'ancien texte
                nameSpan.textContent = opt.text;
              }
            });

            // Valider avec Entr√©e
            nameSpan.addEventListener('keydown', (e) => {
              if (e.key === 'Enter') {
                e.preventDefault();
                nameSpan.blur();
              }
            });
          }

          // Gestion du booster (x2) via la checkbox
          const boosterCheckbox = li.querySelector('.wheel-option-checkbox');
          if (boosterCheckbox) {
            boosterCheckbox.checked = !!opt.boosted;
            boosterCheckbox.onchange = null;
            boosterCheckbox.addEventListener('change', () => {
              if (boosterCheckbox.checked) {
                opt.boosted = true;
                opt.multiplier = 2;
              } else {
                opt.boosted = false;
                opt.multiplier = 1;
              }
              // Appliquer le changement √† toutes les copies dupliqu√©es
              this.applySuspenseMultiplier();
            });
          }

          const deleteBtn =
            li.querySelector('.saved-wheel-btn.btn-little') ||
            li.querySelector('.saved-wheel-btn');
          if (deleteBtn) {
            // On r√©-associe le handler de suppression
            deleteBtn.onclick = null;
            deleteBtn.addEventListener('click', () => {
              this.removeOption(index);
            });
          }

          list.appendChild(li);
        });
        
        // G√©rer l'affichage du slider de suspense
        this.updateSuspenseSliderVisibility();
      }

      /**
       * G√©n√®re une couleur anim√©e avec transition smooth entre les couleurs
       */
      getRainbowColor(time) {
      const colors = [
          { r: 155, g: 246, b: 255 }, // #9bf6ff - bleu clair
          { r: 198, g: 198, b: 237 }, // #c6c6ed - violet clair (transition bleu‚Üírose)
          { r: 241, g: 151, b: 220 }, // #f197dc - rose
          { r: 241, g: 151, b: 220 }, // #f197dc - rose (dupliqu√© pour rester plus longtemps)
          { r: 255, g: 202, b: 40 },  // #ffca28 - jaune
          { r: 255, g: 202, b: 40 },  // #ffca28 - jaune (dupliqu√© pour rester plus longtemps)
          { r: 205, g: 224, b: 147 }  // #cde093 - vert clair (transition jaune‚Üíbleu)
        ];
        
        // Animation ralentie pour voir toutes les couleurs (multiplier par 0.5)
        const position = (time * 0.5) % colors.length;
        const index = Math.floor(position);
        const nextIndex = (index + 1) % colors.length;
        const blend = position - index; // Valeur entre 0 et 1 pour l'interpolation
        
        // Interpolation lin√©aire entre deux couleurs
        const r = Math.round(colors[index].r + (colors[nextIndex].r - colors[index].r) * blend);
        const g = Math.round(colors[index].g + (colors[nextIndex].g - colors[index].g) * blend);
        const b = Math.round(colors[index].b + (colors[nextIndex].b - colors[index].b) * blend);
        
        return `rgb(${r}, ${g}, ${b})`;
      }

      draw() {
        const { ctx, canvas } = this;
        if (!ctx) return;

      ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (!this.options.length) return;

        // Calculer la taille totale en tenant compte des multipliers
        const totalWeight = this.options.reduce((sum, opt) => {
          return sum + (opt.multiplier && opt.multiplier > 0 ? opt.multiplier : 1);
        }, 0);

        const baseAngle = this.rotationAngle;
        const count = this.options.length;
        let currentAngle = baseAngle;

        for (let i = 0; i < count; i++) {
          const weight = this.options[i].multiplier && this.options[i].multiplier > 0 
            ? this.options[i].multiplier 
            : 1;
          
          // L'arc de ce segment est proportionnel √† son multiplier
          const arc = (2 * Math.PI) * (weight / totalWeight);
          
          // Si l'option est boost√©e, appliquer l'effet multicolor, sinon couleur normale
          const isBoosted = this.options[i].boosted && this.options[i].multiplier > 1;
          
          if (isBoosted) {
            // Couleur arc-en-ciel simple qui change avec le temps
            ctx.fillStyle = this.getRainbowColor(this.rainbowTime + i * 0.1);
          } else {
            ctx.fillStyle = this.colors[i % this.colors.length];
          }

          // segment plein (pas de trou au centre)
        ctx.beginPath();
          ctx.moveTo(this.centerX, this.centerY);
          ctx.arc(this.centerX, this.centerY, this.outsideRadius, currentAngle, currentAngle + arc, false);
          ctx.closePath();
        ctx.fill();

          // bordure blanche entre les segments (uniquement s'il y a au moins 2 options)
          if (count > 1) {
            ctx.beginPath();
            ctx.moveTo(this.centerX, this.centerY);
            ctx.lineTo(
              this.centerX + this.outsideRadius * Math.cos(currentAngle),
              this.centerY + this.outsideRadius * Math.sin(currentAngle)
            );
            ctx.lineWidth = 3;
            ctx.strokeStyle = 'white';
            ctx.stroke();
          }

          // Texte vertical au centre du segment, avec trim si trop long
          const rawLabel = this.options[i] && this.options[i].text ? this.options[i].text : '';
          let label = rawLabel.trim();

        ctx.save();
          ctx.translate(this.centerX, this.centerY);
          // on oriente le rep√®re dans l'axe du segment
          ctx.rotate(currentAngle + arc / 2);
          ctx.fillStyle = '#000';
        ctx.font = 'bold 14px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';

          const bandThickness = this.outsideRadius - this.insideRadius;
          const lineHeight = 8;
          const maxLines = Math.max(1, Math.floor((bandThickness - 10) / lineHeight));

          // trim : on garde au plus maxLines caract√®res (approximatif mais efficace)
          if (label.length > maxLines) {
            label = label.slice(0, maxLines - 1) + '‚Ä¶';
          }

          const startRadius = this.insideRadius + 5;
          const totalHeight = label.length * lineHeight;
          const offsetStart = startRadius + (bandThickness - totalHeight) / 2;

          // on dessine chaque caract√®re l'un en dessous de l'autre le long du rayon
          for (let j = 0; j < label.length; j++) {
            const ch = label[j];
            const r = offsetStart + j * lineHeight;
            ctx.fillText(ch, r, 0);
          }

        ctx.restore();
          
          // Passer √† l'angle suivant
          currentAngle += arc;
        }

        // bordure blanche autour de toute la roue
        ctx.beginPath();
        ctx.arc(this.centerX, this.centerY, this.outsideRadius, 0, 2 * Math.PI);
        ctx.lineWidth = 4;
        ctx.strokeStyle = 'white';
        ctx.stroke();
      }

      /**
       * Renvoie l'option actuellement sous l'aiguille.
       */
      getCurrentSegmentIndex() {
        if (!this.options.length) return -1;

        // Calculer la taille totale en tenant compte des multipliers
        const totalWeight = this.options.reduce((sum, opt) => {
          return sum + (opt.multiplier && opt.multiplier > 0 ? opt.multiplier : 1);
        }, 0);

        let angle = this.rotationAngle % (2 * Math.PI);
        if (angle < 0) angle += 2 * Math.PI;

        // L'aiguille pointe vers le haut (angle 0), on inverse pour trouver le segment
        const normalized = (2 * Math.PI - angle) % (2 * Math.PI);

        // Parcourir les segments pour trouver celui sous l'aiguille
        let currentAngle = 0;
        for (let i = 0; i < this.options.length; i++) {
          const weight = this.options[i].multiplier && this.options[i].multiplier > 0 
            ? this.options[i].multiplier 
            : 1;
          const arc = (2 * Math.PI) * (weight / totalWeight);
          
          if (normalized >= currentAngle && normalized < currentAngle + arc) {
            return i;
          }
          currentAngle += arc;
        }
        return 0;
      }

      getCurrentOption() {
        const index = this.getCurrentSegmentIndex();
        if (index === -1) return null;
        this.lastWinnerIndex = index;
        return this.options[index] || null;
      }

      /**
       * Retourne un index al√©atoire pond√©r√© par multiplier (x2, etc.).
       */
      getWeightedRandomIndex() {
        if (!this.options.length) return null;
        const weights = this.options.map((opt) =>
          opt && opt.multiplier && opt.multiplier > 0 ? opt.multiplier : 1
        );
        const total = weights.reduce((sum, w) => sum + w, 0);
        if (total <= 0) return 0;

        let r = Math.random() * total;
        for (let i = 0; i < weights.length; i++) {
          if (r < weights[i]) return i;
          r -= weights[i];
        }
        return 0;
      }

      /**
       * Lance un spin : la roue acc√©l√®re puis ralentit jusqu'√† s'arr√™ter sur une option.
       */
      spin() {
        if (this.isSpinning || !this.options.length) return;

        // on coupe l'auto-rotation lente pendant le spin
        this.isAutoRotating = false;
        this.isSpinning = true;

        // Jouer le son imm√©diatement au d√©marrage du spin
        if (this.tickSound) {
          this.tickSound.currentTime = 0;
          this.tickSound.play().catch(() => {
            // Ignorer les erreurs de lecture (autoplay policy)
          });
        }

        // Initialiser avec le segment actuel pour d√©tecter le prochain changement
        this.lastSegmentIndex = this.getCurrentSegmentIndex();

        const startAngle = this.rotationAngle;
        const n = this.options.length;
        const arc = (2 * Math.PI) / n;

        // Choix de l'index gagnant avec pond√©ration (x2)
        const targetIndex = this.getWeightedRandomIndex() ?? 0;

        // angle qui met le centre du segment gagnant sous l'aiguille
        const targetBaseAngle = (2 * Math.PI - (targetIndex + 0.5) * arc);
        const extraSpins = 4 + Math.random() * 3; // entre 4 et 7 tours complets
        const endAngle = targetBaseAngle + 2 * Math.PI * extraSpins;
        const totalDelta = endAngle - startAngle;
        const duration = 3000; // ms
        const startTime = performance.now();

        const animate = (now) => {
          const t = Math.min(1, (now - startTime) / duration);
          // easing "ease-out" pour un arr√™t en douceur
          const eased = 1 - Math.pow(1 - t, 3);
          this.rotationAngle = startAngle + totalDelta * eased;
          this.draw();

          // D√©tecter le changement de segment pour jouer le son
          const currentSegment = this.getCurrentSegmentIndex();
          if (currentSegment !== -1 && currentSegment !== this.lastSegmentIndex) {
            this.lastSegmentIndex = currentSegment;
            // Jouer le son d√®s qu'on d√©tecte un segment valide
            if (this.tickSound) {
              this.tickSound.currentTime = 0;
              this.tickSound.play().catch(() => {
                // Ignorer les erreurs de lecture (autoplay policy)
              });
            }
          }

          if (t < 1) {
            requestAnimationFrame(animate);
          } else {
            this.isSpinning = false;
            this.lastSegmentIndex = -1; // Reset pour le prochain spin
            const winner = this.getCurrentOption();
            if (typeof this.onSpinEnd === 'function') {
              this.onSpinEnd(winner);
            }
          }
        };

        requestAnimationFrame(animate);
      }

      startAutoRotate() {
        if (this.isAutoRotating) return;
        this.isAutoRotating = true;

        const step = () => {
          if (!this.isAutoRotating) return;
          this.rotationAngle += this.rotationSpeed;
          // √©vite que l'angle ne grossisse √† l'infini
          if (this.rotationAngle > Math.PI * 2) {
            this.rotationAngle -= Math.PI * 2;
          }
          // Incr√©menter le temps pour l'animation arc-en-ciel (plus rapide)
          this.rainbowTime += 0.03;
          this.draw();
          requestAnimationFrame(step);
        };

        requestAnimationFrame(step);
      }
    }

    /**
     * G√®re l'input pour ajouter des options √† la roue.
     */
    // ========================================
    // CLASSE OPTIONINPUTCONTROLLER
    // ========================================
    class OptionInputController {
      constructor(wheelInstance, inputId = 'entry-input') {
        this.wheel = wheelInstance;
        this.input = document.getElementById(inputId);
        
        if (this.input) {
          this.bindEvents();
        }
      }

      bindEvents() {
        this.input.addEventListener('keydown', (event) => {
          if (event.key !== 'Enter') return;

          const value = this.input.value.trim();
          if (!value) return;

          this.wheel.addOption(value);
          this.input.value = '';
        });
      }
    }

    /**
     * G√®re le slider de suspense pour dupliquer les options.
     */
    // ========================================
    // CLASSE SUSPENSESLIDERCONTROLLER
    // ========================================
    class SuspenseSliderController {
      constructor(wheelInstance) {
        this.wheel = wheelInstance;
        this.slider = document.getElementById('suspense-slider');
        this.valueDisplay = document.getElementById('suspense-value');
        
        if (this.slider && this.valueDisplay) {
          this.bindEvents();
        }
      }

      bindEvents() {
        this.slider.addEventListener('input', (event) => {
          const value = parseInt(event.target.value);
          this.valueDisplay.textContent = `x${value}`;
          this.wheel.setSuspenseMultiplier(value);
        });
      }
    }

    /**
     * G√®re le bouton de spin et l'affichage du r√©sultat.
     */
    // ========================================
    // CLASSE SPINCONTROLLER
    // ========================================
    class SpinController {
      constructor(wheelInstance) {
        this.wheel = wheelInstance;
        this.spinButton = document.getElementById('spin');
        this.resultContainer = document.getElementById('result');
        this.resultText = document.getElementById('result-text');
        this.resultClose = document.getElementById('result-close');
        this.resultRemove = document.getElementById('result-remove');

        if (this.spinButton && this.resultContainer && this.resultText) {
          this.init();
        }
      }

      init() {
        this.updateSpinButtonState();
        this.wheel.onOptionsChanged = () => this.updateSpinButtonState();
        this.bindEvents();
      }

      updateSpinButtonState() {
        const hasRealOptions = !this.wheel.usesDefaultOptions && this.wheel.options.length > 0;
        this.spinButton.disabled = !hasRealOptions;
      }

      bindEvents() {
        // Bouton de fermeture du modal r√©sultat
        if (this.resultClose) {
          this.resultClose.addEventListener('click', () => {
            this.hideResult();
          });
        }

        // Bouton pour retirer l'option gagnante de la liste
        if (this.resultRemove) {
          this.resultRemove.addEventListener('click', () => {
            if (typeof this.wheel.lastWinnerIndex === 'number') {
              this.wheel.removeOption(this.wheel.lastWinnerIndex);
              this.hideResult();
            }
          });
        }

        // Bouton de spin
        this.spinButton.addEventListener('click', () => {
          // D√©sactiver le bouton pendant le spin
          this.spinButton.disabled = true;
          this.wheel.onSpinEnd = (winner) => this.showResult(winner);
          this.wheel.spin();
        });
      }

      showResult(winner) {
        if (!winner) return;
        this.resultText.textContent = `ü•íüçëü§åüî• ${String(winner.text)} üî•ü§åüçëü•í`;
        this.resultContainer.classList.add('show');
        this.createConfetti();
        // D√©sactiver le bouton SPIN pendant l'affichage du r√©sultat
        this.spinButton.disabled = true;
      }

      createConfetti() {
        const { CONFETTI_COUNT, CONFETTI_COLORS } = ANIMATION_CONFIG;
        
        for (let i = 0; i < CONFETTI_COUNT; i++) {
          setTimeout(() => {
            const confetti = document.createElement('div');
            confetti.className = 'confetti confetti-animation';
            
            // Style du confetti
            Object.assign(confetti.style, {
              left: `${Math.random() * 100}%`,
              background: CONFETTI_COLORS[Math.floor(Math.random() * CONFETTI_COLORS.length)],
              width: `${Math.random() * 10 + 5}px`,
              height: `${Math.random() * 10 + 5}px`,
              borderRadius: Math.random() > 0.5 ? '50%' : '0',
              animationDuration: `${Math.random() * 3 + 2}s`,
              animationDelay: `${Math.random() * 0.3}s`
            });
            
            confetti.style.setProperty('--drift', `${(Math.random() - 0.5) * 200}px`);
            
            document.body.appendChild(confetti);
            
            // Nettoyage automatique
            setTimeout(() => confetti.remove(), 6000);
          }, i * 8);
        }
      }

      hideResult() {
        this.resultContainer.classList.remove('show');
        this.wheel.startAutoRotate();
        // R√©activer le bouton SPIN (v√©rifie automatiquement s'il y a des options valides)
        this.updateSpinButtonState();
      }
    }

    /**
     * G√®re la persistance et l'affichage des roues sauvegard√©es.
     */
    // ========================================
    // CLASSE SAVEDWHEELSMANAGER
    // ========================================
    class SavedWheelsManager {
      constructor(wheelInstance) {
        if (!wheelInstance) {
          throw new Error('Instance Wheel requise pour SavedWheelsManager');
        }

        this.wheel = wheelInstance;
        this.storageKey = STORAGE_KEYS.SAVED_WHEELS;
        
        // √âl√©ments DOM
        this.savedList = document.querySelector('.saved-wheels');
        this.saveBtn = document.getElementById('save-wheel');
        this.addNewBtn = document.getElementById('add-new-wheel');
        this.importBtn = document.getElementById('import-wheel');
        this.exportBtn = document.getElementById('export-wheel');
        
        // √âtat
        this.savedWheels = [];
        this.currentSavedId = null;
        this.templateItem = null;
        this.lastSavedState = null;

        if (this.savedList) {
          this.init();
        }
      }

      init() {
        // R√©cup√®re un template √† partir du premier item statique
        const existingItem = this.savedList.querySelector('.saved-wheel');
        if (existingItem) {
          this.templateItem = existingItem.cloneNode(true);
        }

        this.loadFromStorage();
        this.renderList();
        this.bindEvents();
        
        // V√©rifier s'il y a des modifications non sauvegard√©es apr√®s un reload
        this.checkUnsavedStateOnLoad();
      }

      /**
       * V√©rifie s'il y a un √©tat non sauvegard√© apr√®s un reload de page
       */
      checkUnsavedStateOnLoad() {
        const unsavedState = Utils.storage.get(STORAGE_KEYS.UNSAVED_STATE);
        
        if (unsavedState && unsavedState.options && unsavedState.options.length > 0) {
          // Il y a des modifications non sauvegard√©es
          const hasCustomOptions = !unsavedState.isDefault;
          
          if (hasCustomOptions) {
            // Afficher la modal pour proposer de sauvegarder
            setTimeout(() => {
              this.showUnsavedChangesModal(
                () => {
                  // Sauvegarder les modifications
                  this.wheel.setOptions(unsavedState.options);
                  this.saveCurrentWheel();
                  Utils.storage.set(STORAGE_KEYS.UNSAVED_STATE, null);
                },
                () => {
                  // Ne pas sauvegarder, supprimer l'√©tat
                  Utils.storage.set(STORAGE_KEYS.UNSAVED_STATE, null);
                }
              );
            }, 500);
          } else {
            // Options par d√©faut, pas besoin de modal
            Utils.storage.set(STORAGE_KEYS.UNSAVED_STATE, null);
          }
        }
      }

      /**
       * Sauvegarde l'√©tat actuel avant un reload (appel√© via beforeunload)
       */
      saveUnsavedState() {
        if (this.hasUnsavedChanges() && !this.wheel.usesDefaultOptions) {
          const state = {
            options: this.wheel.baseOptions,
            isDefault: this.wheel.usesDefaultOptions,
            timestamp: Date.now()
          };
          Utils.storage.set(STORAGE_KEYS.UNSAVED_STATE, state);
        }
      }

      loadFromStorage() {
        const wheels = Utils.storage.get(this.storageKey, []);
        if (Array.isArray(wheels)) {
          this.savedWheels = wheels;
        }
      }

      saveToStorage() {
        Utils.storage.set(this.storageKey, this.savedWheels);
      }

      getNextWheelNumber() {
        let maxNum = 0;
        this.savedWheels.forEach((w) => {
          const match = w.name && w.name.match(/^Roue (\d+)$/);
          if (match) {
            const num = parseInt(match[1], 10);
            if (num > maxNum) maxNum = num;
          }
        });
        return maxNum + 1;
      }

      createWheelSnapshot() {
        const id = this.currentSavedId || Date.now();
        let name;
        
        if (this.currentSavedId) {
          // Si on modifie une roue existante, garder son nom
          const existing = this.savedWheels.find((w) => w.id === this.currentSavedId);
          name = existing ? existing.name : `Roue ${this.getNextWheelNumber()}`;
        } else {
          // Nouvelle roue : nom incr√©mental
          name = `Roue ${this.getNextWheelNumber()}`;
        }

        return {
          id,
          name,
          options: this.wheel.options.map((opt) => ({
            text: opt.text,
            boosted: !!opt.boosted,
            multiplier: opt.multiplier && opt.multiplier > 0 ? opt.multiplier : 1,
          })),
        };
      }

      renderList() {
        this.savedList.innerHTML = '';
        if (!this.templateItem) return;

        this.savedWheels.forEach((wheelData) => {
          const li = this.createWheelListItem(wheelData);
          this.savedList.appendChild(li);
        });
      }

      createWheelListItem(wheelData) {
        const li = this.templateItem.cloneNode(true);
        li.dataset.wheelId = wheelData.id;
        
        const nameSpan = li.querySelector('.saved-wheel-name');
        if (nameSpan) {
          nameSpan.textContent = wheelData.name || 'Roue';
          nameSpan.oninput = null;
          nameSpan.addEventListener('input', () => {
            wheelData.name = nameSpan.textContent.trim() || 'Roue';
            this.saveToStorage();
          });
        }

        const [loadBtn, deleteBtn] = li.querySelectorAll('.saved-wheel-btn.btn-little');

        if (loadBtn) {
          loadBtn.onclick = null;
          loadBtn.addEventListener('click', () => this.loadWheel(wheelData));
        }

        if (deleteBtn) {
          deleteBtn.onclick = null;
          deleteBtn.addEventListener('click', () => this.deleteWheel(wheelData.id));
        }

        return li;
      }

      hasUnsavedChanges() {
        if (!this.lastSavedState) return false;
        
        const currentState = JSON.stringify({
          options: this.wheel.options.map((opt) => ({
            text: opt.text,
            boosted: !!opt.boosted,
            multiplier: opt.multiplier || 1,
          })),
        });
        
        return currentState !== this.lastSavedState;
      }

      updateLastSavedState() {
        this.lastSavedState = JSON.stringify({
          options: this.wheel.options.map((opt) => ({
            text: opt.text,
            boosted: !!opt.boosted,
            multiplier: opt.multiplier || 1,
          })),
        });
      }

      showUnsavedChangesModal(onSave, onDiscard) {
        const modal = document.getElementById('unsaved-changes-modal');
        const saveBtn = document.getElementById('modal-save-btn');
        const discardBtn = document.getElementById('modal-discard-btn');
        const cancelBtn = document.getElementById('modal-cancel-btn');

        if (!modal) return;

        // Fonction pour fermer la modal
        const closeModal = () => {
          modal.classList.remove('show');
          setTimeout(() => {
            modal.style.display = 'none';
          }, 300);
        };

        // Gestionnaires d'√©v√©nements
        const handleSave = () => {
          closeModal();
          onSave();
        };

        const handleDiscard = () => {
          closeModal();
          onDiscard();
        };

        const handleCancel = () => {
          closeModal();
        };

        // Nettoyer les anciens listeners (cloner pour supprimer tous les listeners)
        const newSaveBtn = saveBtn.cloneNode(true);
        const newDiscardBtn = discardBtn.cloneNode(true);
        const newCancelBtn = cancelBtn.cloneNode(true);
        
        saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);
        discardBtn.parentNode.replaceChild(newDiscardBtn, discardBtn);
        cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);

        // Attacher les nouveaux listeners
        newSaveBtn.addEventListener('click', handleSave);
        newDiscardBtn.addEventListener('click', handleDiscard);
        newCancelBtn.addEventListener('click', handleCancel);

        // Afficher la modal avec animation
        modal.style.display = 'flex';
        setTimeout(() => modal.classList.add('show'), 10);
      }

      loadWheel(wheelData) {
        if (this.hasUnsavedChanges()) {
          this.showUnsavedChangesModal(
            () => {
              // Sauvegarder puis charger
              this.saveCurrentWheel();
              this.performLoadWheel(wheelData);
            },
            () => {
              // Ne pas sauvegarder, charger directement
              this.performLoadWheel(wheelData);
            }
          );
        } else {
          this.performLoadWheel(wheelData);
        }
      }

      resetSuspenseSlider() {
        const slider = document.getElementById('suspense-slider');
        const valueDisplay = document.getElementById('suspense-value');
        
        if (slider) {
          slider.value = 1;
        }
        if (valueDisplay) {
          valueDisplay.textContent = 'x1';
        }
        // R√©initialiser le multiplicateur de suspense dans la roue
        this.wheel.setSuspenseMultiplier(1);
      }

      performLoadWheel(wheelData) {
        this.currentSavedId = wheelData.id;
        this.wheel.usesDefaultOptions = false;
        this.wheel.setOptions(wheelData.options || []);
        // R√©initialiser le slider √† 1 pour chaque nouvelle roue charg√©e
        this.resetSuspenseSlider();
        this.updateLastSavedState();
      }

      deleteWheel(wheelId) {
        this.savedWheels = this.savedWheels.filter((w) => w.id !== wheelId);
        if (this.currentSavedId === wheelId) {
          this.currentSavedId = null;
        }
        this.saveToStorage();
        this.renderList();
      }

      saveCurrentWheel() {
        const snapshot = this.createWheelSnapshot();
        const existingIndex = this.savedWheels.findIndex((w) => w.id === this.currentSavedId);
        
        if (existingIndex >= 0) {
          // Mise √† jour d'une roue existante
          this.savedWheels[existingIndex] = snapshot;
        } else {
          // Cr√©ation d'une nouvelle entr√©e (si liste vide ou aucune roue s√©lectionn√©e)
          if (this.savedWheels.length === 0 || !this.currentSavedId) {
            this.savedWheels.push(snapshot);
            this.currentSavedId = snapshot.id;
          } else {
            // Il y a des roues mais aucune n'est s√©lectionn√©e
            this.showNotification('Aucune roue s√©lectionn√©e. Cliquez sur une roue dans la liste ou utilisez "START A NEW WHEEL".', true);
            return;
          }
        }
        
        this.saveToStorage();
        this.renderList();
        this.updateLastSavedState();
        this.showNotification('Roue sauvegard√©e ! üíæ');
      }

      addNewWheel() {
        if (this.hasUnsavedChanges()) {
          this.showUnsavedChangesModal(
            () => {
              // Sauvegarder puis cr√©er nouvelle roue
              this.saveCurrentWheel();
              this.performAddNewWheel();
            },
            () => {
              // Ne pas sauvegarder, cr√©er nouvelle roue directement
              this.performAddNewWheel();
            }
          );
        } else {
          this.performAddNewWheel();
        }
      }

      performAddNewWheel() {
        // Cr√©er un nouvel item dans la liste avec les options par d√©faut (DRAMAS)
        const newWheelId = Date.now();
        const newWheel = {
          id: newWheelId,
          name: `Roue ${this.getNextWheelNumber()}`,
          options: this.wheel.defaultOptions.map((opt) => ({
            text: typeof opt === 'string' ? opt : opt.text,
            boosted: false,
            multiplier: 1,
          })),
        };

        this.savedWheels.push(newWheel);
        this.currentSavedId = newWheelId;
        this.saveToStorage();
        this.renderList();

        // Charger cette nouvelle roue (√©tat par d√©faut DRAMAS)
        // Cacher le slider AVANT de charger les options pour √©viter qu'il apparaisse bri√®vement
        const sliderContainer = document.getElementById('suspense-slider-container');
        if (sliderContainer) {
          sliderContainer.style.display = 'none';
        }
        
        this.wheel.usesDefaultOptions = true;
        this.wheel.setOptions(newWheel.options);
        // R√©initialiser le slider √† 1 pour chaque nouvelle roue cr√©√©e
        this.resetSuspenseSlider();
        // S'assurer que le slider de suspense est bien cach√© pour les options par d√©faut
        this.wheel.updateSuspenseSliderVisibility();
        this.updateLastSavedState();
      }

      async exportWheel() {
        try {
          // Cr√©er un snapshot de la roue actuelle
          const wheelData = {
            name: this.currentSavedId 
              ? this.savedWheels.find((w) => w.id === this.currentSavedId)?.name || 'Roue export√©e'
              : 'Roue export√©e',
            options: this.wheel.options.map((opt) => ({
              text: opt.text,
              boosted: !!opt.boosted,
              multiplier: opt.multiplier && opt.multiplier > 0 ? opt.multiplier : 1,
            })),
          };

          const json = JSON.stringify(wheelData, null, 2);
          
          // Copier dans le presse-papier
          await navigator.clipboard.writeText(json);
          
          // Notification visuelle
          this.showNotification('Roue export√©e dans le presse-papier ! üìã');
        } catch (e) {
          console.error('Erreur lors de l\'export :', e);
          this.showNotification('Erreur lors de l\'export ‚ùå', true);
        }
      }

      async importWheel() {
        try {
          // Lire depuis le presse-papier
          const clipboardText = await navigator.clipboard.readText();
          
          if (!clipboardText) {
            this.showNotification('Presse-papier vide ‚ùå', true);
            return;
          }

          // Parser le JSON
          const wheelData = JSON.parse(clipboardText);
          
          // Valider la structure
          if (!wheelData.options || !Array.isArray(wheelData.options)) {
            this.showNotification('Format invalide ‚ùå', true);
            return;
          }

          // D√©terminer le nom de la roue import√©e
          let wheelName;
          if (wheelData.name) {
            // V√©rifier si le nom existe d√©j√†
            const nameExists = this.savedWheels.some((w) => w.name === wheelData.name);
            if (nameExists) {
              // Si le nom existe, utiliser l'incr√©mentation
              wheelName = `Roue ${this.getNextWheelNumber()}`;
            } else {
              // Sinon, utiliser le nom import√©
              wheelName = wheelData.name;
            }
          } else {
            // Pas de nom fourni, utiliser l'incr√©mentation
            wheelName = `Roue ${this.getNextWheelNumber()}`;
          }

          // Cr√©er une nouvelle entr√©e dans la liste
          const newWheelId = Date.now();
          const newWheel = {
            id: newWheelId,
            name: wheelName,
            options: wheelData.options.map((opt) => ({
              text: opt.text || '',
              boosted: !!opt.boosted,
              multiplier: opt.multiplier && opt.multiplier > 0 ? opt.multiplier : 1,
            })),
          };

          this.savedWheels.push(newWheel);
          this.saveToStorage();
          this.renderList();

          // Charger la roue import√©e
          this.currentSavedId = newWheelId;
          this.wheel.usesDefaultOptions = false;
          this.wheel.setOptions(newWheel.options);
          // R√©initialiser le slider √† 1 pour chaque roue import√©e
          this.resetSuspenseSlider();
          this.updateLastSavedState();

          this.showNotification('Roue import√©e avec succ√®s ! ‚úÖ');
        } catch (e) {
          console.error('Erreur lors de l\'import :', e);
          this.showNotification('Erreur lors de l\'import (JSON invalide ?) ‚ùå', true);
        }
      }

      showNotification(message, isError = false) {
        const notification = document.createElement('div');
        notification.textContent = message;
        notification.style.cssText = `
          position: fixed;
          top: 20px;
          left: 50%;
          transform: translateX(-50%);
          background: ${isError ? '#f496ad' : '#e3b9ff'};
          color: white;
          padding: 15px 30px;
          border-radius: 12px;
          border: 3px solid rgba(255, 255, 255, 0.5);
          font-size: 16px;
          font-weight: 600;
          z-index: 10001;
          box-shadow: 0 4px 12px rgba(203, 97, 163, 0.4);
          animation: slideDown 0.3s ease-out;
        `;

        // Animation CSS
        const style = document.createElement('style');
        style.textContent = `
          @keyframes slideDown {
            from {
              opacity: 0;
              transform: translateX(-50%) translateY(-20px);
            }
            to {
              opacity: 1;
              transform: translateX(-50%) translateY(0);
            }
          }
        `;
        document.head.appendChild(style);

        document.body.appendChild(notification);

        // Supprimer apr√®s 3 secondes
        setTimeout(() => {
          notification.style.opacity = '0';
          notification.style.transition = 'opacity 0.3s';
          setTimeout(() => {
            document.body.removeChild(notification);
            document.head.removeChild(style);
          }, 300);
        }, 3000);
      }

      bindEvents() {
        if (this.saveBtn) {
          this.saveBtn.addEventListener('click', () => this.saveCurrentWheel());
        }

        if (this.addNewBtn) {
          this.addNewBtn.addEventListener('click', () => this.addNewWheel());
        }

        // Boutons Import/Export
        const importBtn = document.getElementById('import-wheel');
        const exportBtn = document.getElementById('export-wheel');

        if (importBtn) {
          importBtn.addEventListener('click', () => this.importWheel());
        }

        if (exportBtn) {
          exportBtn.addEventListener('click', () => this.exportWheel());
        }

        // Sauvegarder l'√©tat avant un reload/fermeture de page
        window.addEventListener('beforeunload', () => {
          this.saveUnsavedState();
        });
      }
    }

    /**
     * Point d'entr√©e principal de l'application.
     */
    // ========================================
    // CLASSE WHEELAPP (ORCHESTRATEUR)
    // ========================================
    class WheelApp {
      constructor() {
        this.canvas = document.getElementById('wheel');
        this.defaultOptions = ['D', 'R', 'A', 'M', 'A', 'S'];
        
        if (this.canvas) {
          this.init();
        }
      }

      init() {
        this.setupCanvas();
        this.createWheel();
        this.createControllers();
      }

      setupCanvas() {
        const displayWidth = this.canvas.clientWidth || 
          (this.canvas.parentElement && this.canvas.parentElement.clientWidth) || 500;
        const displayHeight = this.canvas.clientHeight || 
          (this.canvas.parentElement && this.canvas.parentElement.clientHeight) || 500;
        this.canvas.width = displayWidth;
        this.canvas.height = displayHeight;
      }

      createWheel() {
        // true => ces options sont consid√©r√©es comme "par d√©faut"
        this.wheel = new Wheel(this.canvas, this.defaultOptions, true);
        this.wheel.draw();
        this.wheel.startAutoRotate(); // rotation lente par d√©faut

        // Synchronise les options avec la liste du panneau droit
        const optionsList = document.querySelector('.wheel-options-list');
        if (optionsList) {
          this.wheel.attachOptionsList(optionsList);
        }
      }

      createControllers() {
        // Initialise tous les contr√¥leurs
        this.optionInputController = new OptionInputController(this.wheel);
        this.suspenseSliderController = new SuspenseSliderController(this.wheel);
        this.spinController = new SpinController(this.wheel);
        this.savedWheelsManager = new SavedWheelsManager(this.wheel);
      }
    }

    /**
     * G√®re le background al√©atoire avec mise en cache et chargement optimis√©.
     */
    // ========================================
    // CLASSE BACKGROUNDMANAGER
    // ========================================
    class BackgroundManager {
      constructor() {
        this.storageKey = STORAGE_KEYS.LAST_BACKGROUND;
        this.storageTitleKey = STORAGE_KEYS.LAST_TITLE;
        
        // Chaque background est associ√© √† son titre correspondant
        this.backgrounds = [
          {
            bg: 'https://64.media.tumblr.com/5580f3a703c42e3332294d2ff42e7408/tumblr_inline_t6i370Z42U1yrz37b_1280.png',
            title: 'https://64.media.tumblr.com/6aa194932d0b03f26fc3ab38a763c82e/tumblr_inline_t6i35ljUhH1yrz37b_1280.png'
          },
          {
            bg: 'https://64.media.tumblr.com/74b76e3320060177494b4f236987acee/tumblr_inline_t6i396kln51yrz37b_1280.png',
            title: 'https://64.media.tumblr.com/582263fe7d215d01f451a7c277ecb86d/tumblr_inline_t6i38rzZpp1yrz37b_1280.png'
          },
          {
            bg: 'https://64.media.tumblr.com/5076166288e7f6eccd9362b5d46e650f/tumblr_inline_t6iikuNZR11yrz37b_1280.png',
            title: 'https://64.media.tumblr.com/44754ad8cab4b3034cc14582f3fd0f68/tumblr_inline_t6iikgZO501yrz37b_1280.png'
          },
          {
            bg: 'https://64.media.tumblr.com/97823d74959cec5b61bc5110efc16dc7/tumblr_inline_t6iinlQ3Oe1yrz37b_1280.png',
            title: 'https://64.media.tumblr.com/4128a59a239e52decba084887326a5a5/tumblr_inline_t6iin87bZu1yrz37b_1280.png'
          },
          {
            bg: 'https://64.media.tumblr.com/ec3b18cba87b5f0f5b73b4009feb9847/tumblr_inline_t6iirnJqn21yrz37b_1280.png',
            title: 'https://64.media.tumblr.com/2e53e915893b445a6a43ed60a5582876/tumblr_inline_t6iiqou76b1yrz37b_1280.png'
          },
          {
            bg: 'https://64.media.tumblr.com/69c18429d2748da583ac0515eb70e691/tumblr_inline_t6iisg3T4D1yrz37b_1280.png',
            title: 'https://64.media.tumblr.com/8ac3f99769653bb4ff329bacf35773c7/tumblr_inline_t6iisaAKzU1yrz37b_1280.png'
          },
          {
            bg: 'https://64.media.tumblr.com/92f6c15e22a3aec98d9d3a9aac966236/tumblr_inline_t6iiuil6WS1yrz37b_1280.png',
            title: 'https://64.media.tumblr.com/77419b415aee81d876807ee368ac2c32/tumblr_inline_t6iitriSpV1yrz37b_1280.png'
          },
          {
            bg: 'https://64.media.tumblr.com/7483b18d09498318b7d2b1f8d277f966/tumblr_inline_t6iivyzOZ81yrz37b_1280.png',
            title: 'https://64.media.tumblr.com/f3f0672ffa6b77ba09a2d0b834506406/tumblr_inline_t6iiv96RCp1yrz37b_1280.png'
          },
          {
            bg: 'https://64.media.tumblr.com/0f79cc668dc8a94895ccb51309081929/tumblr_inline_t6iiwv1Vhp1yrz37b_1280.png',
            title: 'https://64.media.tumblr.com/d1deeaf033d0e65ea9d1344360ba72bd/tumblr_inline_t6iiwhWoHw1yrz37b_1280.png'
          },
          {
            bg: 'https://64.media.tumblr.com/f03a86278cf4c922e5ab50dfba8fe675/tumblr_inline_t6iiybQaN61yrz37b_1280.png',
            title: 'https://64.media.tumblr.com/8cc2f184907afcf04d5308e13e536559/tumblr_inline_t6iixfaPy31yrz37b_1280.png'
          },
          {
            bg: 'https://64.media.tumblr.com/b6b952d11123c4378987a08436d28862/tumblr_inline_t6iiz3ACbF1yrz37b_1280.png',
            title: 'https://64.media.tumblr.com/ca9b43f021bdf607ef2cb3e9af54c565/tumblr_inline_t6iiyuqrZ71yrz37b_1280.png'
          },
          {
            bg: 'https://64.media.tumblr.com/0b02a7a88a2f0f2f043a26926e3d73ac/tumblr_inline_t6ij091k3i1yrz37b_1280.png',
            title: 'https://64.media.tumblr.com/7f9b442e1b29684a5aec80ce1664960e/tumblr_inline_t6ij0gIc2e1yrz37b_1280.png'
          },
          {
            bg: 'https://64.media.tumblr.com/b74d4d63132d0e7fd09058cda1112b68/tumblr_inline_t6ij2cQYgU1yrz37b_1280.png',
            title: 'https://64.media.tumblr.com/00016ed2d94bbcc186d7519a589418eb/tumblr_inline_t6ij1yr5r91yrz37b_1280.png'
          },
          {
            bg: 'https://64.media.tumblr.com/003b17da2736ff8b6590edae331baec6/tumblr_inline_t6ij3jO2Av1yrz37b_1280.png',
            title: 'https://64.media.tumblr.com/293e6a60727f78db4276847a865532f2/tumblr_inline_t6ij39w9hF1yrz37b_1280.png'
          },
          {
            bg: 'https://64.media.tumblr.com/96dad144cd322b1737acb9f297e92233/tumblr_inline_t6ij4wCxHk1yrz37b_1280.png',
            title: 'https://64.media.tumblr.com/a66841639f9bffe4a70541318238703c/tumblr_inline_t6ij4h1R901yrz37b_1280.png'
          },
          {
            bg: 'https://64.media.tumblr.com/3de8cfc893cba90993f0990b2a52bb71/tumblr_inline_t6ij6pD55G1yrz37b_1280.png',
            title: 'https://64.media.tumblr.com/ff1e8de7ecfb5cb0113ee29f2e8e25fe/tumblr_inline_t6ij69qp9i1yrz37b_1280.png'
          },
          {
            bg: 'https://64.media.tumblr.com/884a1fdf57a80263c4c1ef44d719d177/tumblr_inline_t6ij7roLB51yrz37b_1280.png',
            title: 'https://64.media.tumblr.com/a1765b39ae15637125363e644a068fd8/tumblr_inline_t6ij7zNxcB1yrz37b_1280.png'
          },
          {
            bg: 'https://64.media.tumblr.com/ee4b1b5f5c8f2d904bc421c1d3dc0ea8/tumblr_inline_t6ij9bp2lj1yrz37b_1280.png',
            title: 'https://64.media.tumblr.com/c400db4edd98e98d09569a6efe311039/tumblr_inline_t6ij91MaXQ1yrz37b_1280.png'
          },
          {
            bg: 'https://64.media.tumblr.com/bee9d4c9680c4e99c0814432657ecf20/tumblr_inline_t6ijab8ch51yrz37b_1280.png',
            title: 'https://64.media.tumblr.com/46cbc52df11db279a54b65d661f11b53/tumblr_inline_t6ijak0snP1yrz37b_1280.png'
          },
          {
            bg: 'https://64.media.tumblr.com/df5977ccbb59ca101913800a36f17607/tumblr_inline_t6ijc0DaWx1yrz37b_1280.png',
            title: 'https://64.media.tumblr.com/f0bef35219d663789957b22d27a0f55c/tumblr_inline_t6ijbqWJtJ1yrz37b_1280.png'
          },
          {
            bg: 'https://64.media.tumblr.com/49f29b6b53620d7293a315f03ea80a7b/tumblr_inline_t6ijddp7671yrz37b_1280.png',
            title: 'https://64.media.tumblr.com/9385ae5cbc64c9626215c378daf31637/tumblr_inline_t6ijd1aBWn1yrz37b_1280.png'
          },
          {
            bg: 'https://64.media.tumblr.com/7f9bdfe5c16e888e509d47d9951057f2/tumblr_inline_t6ijeo9W3w1yrz37b_1280.png',
            title: 'https://64.media.tumblr.com/a5c1dd5f387e37a954f97ed319731c85/tumblr_inline_t6ijedeN4v1yrz37b_1280.png'
          },
          {
            bg: 'https://64.media.tumblr.com/853c9324566060cb81b5cc5bc52a0e03/tumblr_inline_t6ijfusxbf1yrz37b_1280.png',
            title: 'https://64.media.tumblr.com/3d7359c43ef03f207f2975e6cfff5736/tumblr_inline_t6ijfoUrTO1yrz37b_1280.png'
          },
          {
            bg: 'https://64.media.tumblr.com/f27458a2934a10360726dc264a48b199/tumblr_inline_t6ijgzYeRF1yrz37b_1280.png',
            title: 'https://64.media.tumblr.com/d83e8b56d607785bc3a1d9c0784f8a4f/tumblr_inline_t6ijgpsveh1yrz37b_1280.png'
          }
        ];
        
        this.init();
      }

      init() {
        const appLayout = document.querySelector('.app-layout');
        const wheelTitle = document.querySelector('.wheel-title');
        if (!appLayout) return;

        // R√©cup√©rer et afficher imm√©diatement le background et titre pr√©c√©dents s'ils existent
        const lastBg = this.getLastBackground();
        const lastTitle = this.getLastTitle();
        if (lastBg) {
          appLayout.style.backgroundImage = `url('${lastBg}')`;
        } else {
          // Premi√®re visite : couleur de fond
          appLayout.classList.add('loading');
        }
        if (lastTitle && wheelTitle) {
          wheelTitle.innerHTML = `<img src="${lastTitle}" alt="Titre">`;
        }

        // Choisir un nouveau background al√©atoire √† chaque rechargement
        const randomIndex = Math.floor(Math.random() * this.backgrounds.length);
        const selected = this.backgrounds[randomIndex];
        
        // Sauvegarder pour la prochaine fois
        this.saveLastBackground(selected.bg);
        this.saveLastTitle(selected.title);
        
        // Charger et appliquer avec transition douce
        this.loadBackgroundWithTransition(selected.bg, selected.title);
      }

      getLastBackground() {
        return Utils.storage.getString(this.storageKey);
      }

      getLastTitle() {
        return Utils.storage.getString(this.storageTitleKey);
      }

      saveLastBackground(url) {
        Utils.storage.setString(this.storageKey, url);
      }

      saveLastTitle(url) {
        Utils.storage.setString(this.storageTitleKey, url);
      }

      loadBackgroundWithTransition(bgUrl, titleUrl) {
        const appLayout = document.querySelector('.app-layout');
        const wheelTitle = document.querySelector('.wheel-title');
        if (!appLayout) return;

        // Pr√©charger compl√®tement la nouvelle image de fond
        const img = new Image();
        
        img.onload = () => {
          // Une fois l'image compl√®tement charg√©e, faire une transition douce
          // En r√©duisant temporairement l'opacit√© puis en changeant l'image
          appLayout.style.transition = 'opacity 0.5s ease-in-out';
          appLayout.style.opacity = '0.7';
          
          setTimeout(() => {
            appLayout.style.backgroundImage = `url('${bgUrl}')`;
            appLayout.classList.remove('loading');
            
            // Charger le titre √©galement
            if (wheelTitle && titleUrl) {
              wheelTitle.innerHTML = `<img src="${titleUrl}" alt="Titre">`;
            }
            
            setTimeout(() => {
              appLayout.style.opacity = '1';
              // Retirer la transition apr√®s pour ne pas affecter les autres changements
              setTimeout(() => {
                appLayout.style.transition = '';
              }, 500);
            }, 50);
          }, 500);
        };
        
        img.onerror = () => {
          console.error('Erreur de chargement du background:', bgUrl);
          appLayout.classList.remove('loading');
          // Garder l'ancienne image en cas d'erreur
        };
        
        // D√©clencher le chargement
        img.src = bgUrl;
      }
    }

    /**
     * G√®re le mode plein √©cran
     */
    // ========================================
    // CLASSE FULLSCREENMANAGER
    // ========================================
    class FullscreenManager {
      constructor() {
        this.isFullscreen = false;
        this.appLayout = document.querySelector('.app-layout');
        this.toggleBtn = document.getElementById('fullscreen-toggle');
        
        if (this.toggleBtn) {
          this.toggleBtn.addEventListener('click', () => this.toggle());
        }
      }

      toggle() {
        this.isFullscreen = !this.isFullscreen;
        
        if (this.isFullscreen) {
          this.appLayout.classList.add('fullscreen-mode');
          this.toggleBtn.textContent = '‚úï';
          this.toggleBtn.title = 'Quitter le plein √©cran';
        } else {
          this.appLayout.classList.remove('fullscreen-mode');
          this.toggleBtn.textContent = '‚õ∂';
          this.toggleBtn.title = 'Mode plein √©cran';
        }
      }
    }

    /**
     * G√®re le menu mobile pour le left-panel
     */
    // ========================================
    // CLASSE MOBILEMENUMANAGER
    // ========================================
    class MobileMenuManager {
      constructor() {
        this.menuBtn = document.getElementById('mobile-menu-btn');
        this.overlay = document.getElementById('mobile-menu-overlay');
        this.leftPanel = document.querySelector('.left-panel');
        
        if (this.menuBtn && this.overlay && this.leftPanel) {
          this.menuBtn.addEventListener('click', () => this.open());
          this.overlay.addEventListener('click', () => this.close());
        }
      }

      open() {
        this.leftPanel.classList.add('open');
        this.overlay.classList.add('active');
      }

      close() {
        this.leftPanel.classList.remove('open');
        this.overlay.classList.remove('active');
      }
    }

    /**
     * G√®re l'ouverture/fermeture du panel de notes
     */
    // ========================================
    // CLASSE NOTEPANELMANAGER
    // ========================================
    class NotePanelManager {
      constructor() {
        this.noteTab = document.getElementById('note-tab');
        this.sideNote = document.getElementById('side-note');
        this.overlay = document.getElementById('side-note-overlay');
        this.closeBtn = document.getElementById('side-note-close');
        this.isOpen = false;
        
        if (this.noteTab && this.sideNote) {
          this.noteTab.addEventListener('click', () => this.toggle());
          
          if (this.closeBtn) {
            this.closeBtn.addEventListener('click', () => this.close());
            this.closeBtn.addEventListener('mousedown', (e) => {
              e.target.style.transform = 'scale(0.85)';
            });
            this.closeBtn.addEventListener('mouseup', (e) => {
              e.target.style.transform = 'scale(1)';
            });
          }
          
          // Fermer en cliquant sur l'overlay
          if (this.overlay) {
            this.overlay.addEventListener('click', () => this.close());
          }
          
          // Emp√™cher la fermeture quand on clique dans le panel
          this.sideNote.addEventListener('click', (e) => {
            e.stopPropagation();
          });
          
        }
      }

      toggle() {
        if (this.isOpen) {
          this.close();
        } else {
          this.open();
        }
      }

      open() {
        this.sideNote.classList.add('open');
        if (this.overlay) {
          this.overlay.classList.add('active');
        }
        this.isOpen = true;
      }

      close() {
        this.sideNote.classList.remove('open');
        if (this.overlay) {
          this.overlay.classList.remove('active');
        }
        this.isOpen = false;
      }

    }

    // D√©marrage de l'application
    document.addEventListener('DOMContentLoaded', () => {
      new BackgroundManager();
      new WheelApp();
      new FullscreenManager();
      new NotePanelManager();
      new MobileMenuManager();
    });
  </script>

</body>

</html>
