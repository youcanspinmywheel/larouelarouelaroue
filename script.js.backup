'use strict';

    // ========================================
    // CONSTANTES
    // ========================================
    const STORAGE_KEYS = {
      SAVED_WHEELS: 'toto-saved-wheels',
      LAST_BACKGROUND: 'wheel-last-background',
      LAST_TITLE: 'wheel-last-title',
      UNSAVED_STATE: 'wheel-unsaved-state'
    };

    const WHEEL_CONFIG = {
      COLORS: [
        '#ece9f9', '#ddd8f0', '#fde4cf', '#ffcfd2', '#f1c0e8', '#cfbaf0',
        '#a3c4f3', '#90dbf4', '#8eecf5', '#98f5e1', '#b9fbc0'
      ],
      ROTATION_SPEED: 0.002,
      SPIN_DURATION: 3000,
      MIN_EXTRA_SPINS: 4,
      MAX_EXTRA_SPINS: 7,
      TICK_SOUND_URL: 'asset/sounds/bip.mp3',
      TICK_SOUND_VOLUME: 0.3
    };

    const ANIMATION_CONFIG = {
      CONFETTI_COUNT: 150,
      CONFETTI_COLORS: ['#ff6b6b', '#4ecdc4', '#ffe66d', '#95e1d3', '#f38181', '#aa96da', '#fcbad3', '#a8e6cf']
    };

    // ========================================
    // UTILITAIRES
    // ========================================
    const Utils = {
      /**
       * Normalise une option en objet
       */
      normalizeOption(opt) {
        if (typeof opt === 'string') {
          return { text: opt, boosted: false, multiplier: 1 };
        }
        return {
          text: opt.text,
          boosted: !!opt.boosted,
          multiplier: opt.multiplier && opt.multiplier > 0 ? opt.multiplier : 1
        };
      },

      /**
       * G√©n√®re un ID unique
       */
      generateId() {
        return `wheel-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      },

      /**
       * Gestion s√©curis√©e du localStorage
       */
      storage: {
        get(key, defaultValue = null) {
          try {
            const item = localStorage.getItem(key);
            return item ? JSON.parse(item) : defaultValue;
          } catch (e) {
            console.error(`Erreur lors de la lecture de ${key}:`, e);
            return defaultValue;
          }
        },

        set(key, value) {
          try {
            localStorage.setItem(key, JSON.stringify(value));
            return true;
          } catch (e) {
            console.error(`Erreur lors de l'√©criture de ${key}:`, e);
            return false;
          }
        },

        getString(key, defaultValue = null) {
          try {
            return localStorage.getItem(key) || defaultValue;
          } catch (e) {
            console.error(`Erreur lors de la lecture de ${key}:`, e);
            return defaultValue;
          }
        },

        setString(key, value) {
          try {
            localStorage.setItem(key, value);
            return true;
          } catch (e) {
            console.error(`Erreur lors de l'√©criture de ${key}:`, e);
            return false;
          }
        }
      }
    };

    // ========================================
    // CLASSE WHEEL
    // ========================================
    class Wheel {
      /**
       * @param {HTMLCanvasElement} canvas
       * @param {Array<string|{text:string}>} options
       */
      constructor(canvas, options = [], useAsDefaults = false) {
        if (!canvas || !canvas.getContext) {
          throw new Error('Canvas invalide fourni au constructeur Wheel');
        }

        // Canvas et contexte
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        
        // Configuration visuelle
        this.colors = WHEEL_CONFIG.COLORS;
        this.centerX = this.canvas.width / 2;
        this.centerY = this.canvas.height / 2;
        const maxRadius = Math.min(this.centerX, this.centerY);
        this.outsideRadius = maxRadius - 15;
        this.insideRadius = Math.max(25, this.outsideRadius * 0.15);

        // Options
        this.options = (options || []).map(Utils.normalizeOption);
        this.baseOptions = [];
        this.defaultOptions = useAsDefaults ? this.options.map(opt => ({ ...opt })) : [];
        this.usesDefaultOptions = !!useAsDefaults;
        this.hasAddedNewOption = false;

        // Animation et rotation
        this.rotationAngle = 0;
        this.rotationSpeed = WHEEL_CONFIG.ROTATION_SPEED;
        this.isAutoRotating = false;
        this.isSpinning = false;
        this.rainbowTime = 0;

        // Audio
        this.tickSound = new Audio(WHEEL_CONFIG.TICK_SOUND_URL);
        this.tickSound.volume = WHEEL_CONFIG.TICK_SOUND_VOLUME;
        this.lastSegmentIndex = -1;

        // Callbacks et √©tat
        this.onSpinEnd = null;
        this.onOptionsChanged = null;
        this.lastWinnerIndex = null;

        // DOM
        this.optionsListElement = null;
        this.optionItemTemplate = null;
        this.emptyMessageElement = null;

        // Suspense
        this.suspenseMultiplier = 1;
      }

      /**
       * R√©initialise la roue sur ses valeurs par d√©faut (D R A M A S).
       */
      resetToDefault() {
        if (!this.defaultOptions.length) return;
        this.options = this.defaultOptions.map((opt) => ({ ...opt }));
        this.usesDefaultOptions = true;
        this.draw();
        this.updateOptionsList();
        this.notifyOptionsChanged();
      }

      setOptions(options) {
        this.baseOptions = (options || []).map(Utils.normalizeOption);
        this.applySuspenseMultiplier();
      }
      
      /**
       * Applique le multiplicateur de suspense en dupliquant les options
       */
      applySuspenseMultiplier() {
        if (this.suspenseMultiplier <= 1) {
          this.options = this.baseOptions.map(opt => ({ ...opt }));
        } else {
          this.options = [];
          for (let i = 0; i < this.suspenseMultiplier; i++) {
            this.baseOptions.forEach(opt => {
              this.options.push({ ...opt });
            });
          }
        }
        this.draw();
        this.updateOptionsList();
        this.notifyOptionsChanged();
      }
      
      /**
       * Modifie le multiplicateur de suspense
       */
      setSuspenseMultiplier(multiplier) {
        this.suspenseMultiplier = Math.max(1, Math.min(5, parseInt(multiplier) || 1));
        this.applySuspenseMultiplier();
      }

      /**
       * Ajoute une option. Lors du premier ajout, on supprime les valeurs par d√©faut.
       */
      addOption(optionLabel) {
        const value = String(optionLabel || '').trim();
        if (!value) return;

        if (this.usesDefaultOptions) {
          this.baseOptions = [];
          this.usesDefaultOptions = false;
        }

        this.baseOptions.push({ text: value, boosted: false, multiplier: 1 });
        this.applySuspenseMultiplier();
        
        // Marquer qu'une nouvelle option a √©t√© ajout√©e (pour la gestion des sauvegardes)
        this.hasAddedNewOption = true;
      }

      /**
       * Supprime une option par index (pour √™tre align√© avec le style de script.js).
       */
      removeOption(index) {
        // Trouver l'index dans baseOptions (diviser par suspenseMultiplier)
        const baseIndex = Math.floor(index / this.suspenseMultiplier);
        if (baseIndex < 0 || baseIndex >= this.baseOptions.length) return;
        
        this.baseOptions.splice(baseIndex, 1);
        
        // Si tout a √©t√© supprim√© et qu'on a des valeurs par d√©faut, on les restaure
        if (!this.baseOptions.length && this.defaultOptions.length) {
          this.baseOptions = this.defaultOptions.map((opt) => ({ ...opt }));
          this.usesDefaultOptions = true;
        }
        
        this.applySuspenseMultiplier();
      }

      /**
       * Attache la liste DOM (ul.wheel-options-list) pour refl√©ter les options.
       */
      attachOptionsList(element) {
        this.optionsListElement = element;
        // On m√©morise un template √† partir du premier item existant
        if (!this.optionItemTemplate) {
          const existingItem = element.querySelector('.wheel-option-item');
          if (existingItem) {
            this.optionItemTemplate = existingItem.cloneNode(true);
          }
        }
        // On r√©cup√®re l'√©l√©ment de message (en dehors de la liste)
        if (!this.emptyMessageElement && element.parentElement) {
          this.emptyMessageElement = element.parentElement.querySelector('.wheel-options-empty');
        }
        // On vide la liste pour repartir proprement : tout sera r√©g√©n√©r√©
        this.optionsListElement.innerHTML = '';
        this.updateOptionsList();
      }

      /**
       * Notifie l'UI que les options ont chang√© (pour, par ex., activer/d√©sactiver le bouton SPIN).
       */
      notifyOptionsChanged() {
        if (typeof this.onOptionsChanged === 'function') {
          this.onOptionsChanged(this);
        }
      }
      
      /**
       * G√®re l'affichage du slider de suspense
       */
      updateSuspenseSliderVisibility() {
        const sliderContainer = document.getElementById('suspense-slider-container');
        if (sliderContainer) {
          // Afficher le slider seulement si on a au moins 2 options de base et qu'on n'est pas en mode default
          const shouldShow = !this.usesDefaultOptions && this.baseOptions.length >= 2;
          sliderContainer.style.display = shouldShow ? 'block' : 'none';
        }
      }

      /**
       * Met √† jour le panneau de droite (wheel-option-item) √† partir des options.
       */
      updateOptionsList() {
        if (!this.optionsListElement) return;

        const list = this.optionsListElement;
        list.innerHTML = '';

        // Si on n'a pas r√©ussi √† r√©cup√©rer un template, on ne fait rien
        if (!this.optionItemTemplate) {
          return;
        }

        const isDefaultState = this.usesDefaultOptions && this.defaultOptions.length;

        // Affichage / masquage du message HTML d√©di√©
        if (this.emptyMessageElement) {
          this.emptyMessageElement.style.display = isDefaultState ? 'block' : 'none';
        }

        // En √©tat par d√©faut, on n'affiche aucune option dans la liste
        if (isDefaultState) {
          return;
        }

        // Afficher uniquement les options de base (pas les duplicatas)
        this.baseOptions.forEach((opt, index) => {
          // On clone simplement le <li> template
          const li = this.optionItemTemplate.cloneNode(true);

          const nameSpan = li.querySelector('.wheel-option-name');
          if (nameSpan) {
            nameSpan.textContent = opt && opt.text ? opt.text : '';
            
            // Rendre l'option √©ditable
            nameSpan.setAttribute('contenteditable', 'plaintext-only');
            
            // Sauvegarder les modifications lors de l'√©dition
            nameSpan.addEventListener('blur', () => {
              const newText = nameSpan.textContent.trim();
              if (newText && newText !== opt.text) {
                opt.text = newText;
                this.applySuspenseMultiplier();
              } else if (!newText) {
                // Si vide, restaurer l'ancien texte
                nameSpan.textContent = opt.text;
              }
            });

            // Valider avec Entr√©e
            nameSpan.addEventListener('keydown', (e) => {
              if (e.key === 'Enter') {
                e.preventDefault();
                nameSpan.blur();
              }
            });
          }

          // Gestion du booster (x2) via la checkbox
          const boosterCheckbox = li.querySelector('.wheel-option-checkbox');
          if (boosterCheckbox) {
            boosterCheckbox.checked = !!opt.boosted;
            boosterCheckbox.onchange = null;
            boosterCheckbox.addEventListener('change', () => {
              if (boosterCheckbox.checked) {
                opt.boosted = true;
                opt.multiplier = 2;
              } else {
                opt.boosted = false;
                opt.multiplier = 1;
              }
              // Appliquer le changement √† toutes les copies dupliqu√©es
              this.applySuspenseMultiplier();
            });
          }

          const deleteBtn =
            li.querySelector('.saved-wheel-btn.btn-little') ||
            li.querySelector('.saved-wheel-btn');
          if (deleteBtn) {
            // On r√©-associe le handler de suppression
            deleteBtn.onclick = null;
            deleteBtn.addEventListener('click', () => {
              this.removeOption(index);
            });
          }

          list.appendChild(li);
        });
        
        // G√©rer l'affichage du slider de suspense
        this.updateSuspenseSliderVisibility();
      }

      /**
       * G√©n√®re une couleur anim√©e avec transition smooth entre les couleurs
       */
      getRainbowColor(time) {
      const colors = [
          { r: 155, g: 246, b: 255 }, // #9bf6ff - bleu clair
          { r: 198, g: 198, b: 237 }, // #c6c6ed - violet clair (transition bleu‚Üírose)
          { r: 241, g: 151, b: 220 }, // #f197dc - rose
          { r: 241, g: 151, b: 220 }, // #f197dc - rose (dupliqu√© pour rester plus longtemps)
          { r: 255, g: 202, b: 40 },  // #ffca28 - jaune
          { r: 255, g: 202, b: 40 },  // #ffca28 - jaune (dupliqu√© pour rester plus longtemps)
          { r: 205, g: 224, b: 147 }  // #cde093 - vert clair (transition jaune‚Üíbleu)
        ];
        
        // Animation ralentie pour voir toutes les couleurs (multiplier par 0.5)
        const position = (time * 0.5) % colors.length;
        const index = Math.floor(position);
        const nextIndex = (index + 1) % colors.length;
        const blend = position - index; // Valeur entre 0 et 1 pour l'interpolation
        
        // Interpolation lin√©aire entre deux couleurs
        const r = Math.round(colors[index].r + (colors[nextIndex].r - colors[index].r) * blend);
        const g = Math.round(colors[index].g + (colors[nextIndex].g - colors[index].g) * blend);
        const b = Math.round(colors[index].b + (colors[nextIndex].b - colors[index].b) * blend);
        
        return `rgb(${r}, ${g}, ${b})`;
      }

      draw() {
        const { ctx, canvas } = this;
        if (!ctx) return;

      ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (!this.options.length) return;

        // Calculer la taille totale en tenant compte des multipliers
        const totalWeight = this.options.reduce((sum, opt) => {
          return sum + (opt.multiplier && opt.multiplier > 0 ? opt.multiplier : 1);
        }, 0);

        const baseAngle = this.rotationAngle;
        const count = this.options.length;
        let currentAngle = baseAngle;

        for (let i = 0; i < count; i++) {
          const weight = this.options[i].multiplier && this.options[i].multiplier > 0 
            ? this.options[i].multiplier 
            : 1;
          
          // L'arc de ce segment est proportionnel √† son multiplier
          const arc = (2 * Math.PI) * (weight / totalWeight);
          
          // Si l'option est boost√©e, appliquer l'effet multicolor, sinon couleur normale
          const isBoosted = this.options[i].boosted && this.options[i].multiplier > 1;
          
          if (isBoosted) {
            // Couleur arc-en-ciel simple qui change avec le temps
            ctx.fillStyle = this.getRainbowColor(this.rainbowTime + i * 0.1);
          } else {
            ctx.fillStyle = this.colors[i % this.colors.length];
          }

          // segment plein (pas de trou au centre)
        ctx.beginPath();
          ctx.moveTo(this.centerX, this.centerY);
          ctx.arc(this.centerX, this.centerY, this.outsideRadius, currentAngle, currentAngle + arc, false);
          ctx.closePath();
        ctx.fill();

          // bordure blanche entre les segments (uniquement s'il y a au moins 2 options)
          if (count > 1) {
            ctx.beginPath();
            ctx.moveTo(this.centerX, this.centerY);
            ctx.lineTo(
              this.centerX + this.outsideRadius * Math.cos(currentAngle),
              this.centerY + this.outsideRadius * Math.sin(currentAngle)
            );
            ctx.lineWidth = 3;
            ctx.strokeStyle = 'white';
            ctx.stroke();
          }

          // Texte vertical au centre du segment, avec trim si trop long
          const rawLabel = this.options[i] && this.options[i].text ? this.options[i].text : '';
          let label = rawLabel.trim();

        ctx.save();
          ctx.translate(this.centerX, this.centerY);
          // on oriente le rep√®re dans l'axe du segment
          ctx.rotate(currentAngle + arc / 2);
          ctx.fillStyle = '#000';
        ctx.font = 'bold 14px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';

          const bandThickness = this.outsideRadius - this.insideRadius;
          const lineHeight = 8;
          const maxLines = Math.max(1, Math.floor((bandThickness - 10) / lineHeight));

          // trim : on garde au plus maxLines caract√®res (approximatif mais efficace)
          if (label.length > maxLines) {
            label = label.slice(0, maxLines - 1) + '‚Ä¶';
          }

          const startRadius = this.insideRadius + 5;
          const totalHeight = label.length * lineHeight;
          const offsetStart = startRadius + (bandThickness - totalHeight) / 2;

          // on dessine chaque caract√®re l'un en dessous de l'autre le long du rayon
          for (let j = 0; j < label.length; j++) {
            const ch = label[j];
            const r = offsetStart + j * lineHeight;
            ctx.fillText(ch, r, 0);
          }

        ctx.restore();
          
          // Passer √† l'angle suivant
          currentAngle += arc;
        }

        // bordure blanche autour de toute la roue
        ctx.beginPath();
        ctx.arc(this.centerX, this.centerY, this.outsideRadius, 0, 2 * Math.PI);
        ctx.lineWidth = 4;
        ctx.strokeStyle = 'white';
        ctx.stroke();
      }

      /**
       * Renvoie l'option actuellement sous l'aiguille.
       */
      getCurrentSegmentIndex() {
        if (!this.options.length) return -1;

        // Calculer la taille totale en tenant compte des multipliers
        const totalWeight = this.options.reduce((sum, opt) => {
          return sum + (opt.multiplier && opt.multiplier > 0 ? opt.multiplier : 1);
        }, 0);

        let angle = this.rotationAngle % (2 * Math.PI);
        if (angle < 0) angle += 2 * Math.PI;

        // L'aiguille pointe vers le haut (angle 0), on inverse pour trouver le segment
        const normalized = (2 * Math.PI - angle) % (2 * Math.PI);

        // Parcourir les segments pour trouver celui sous l'aiguille
        let currentAngle = 0;
        for (let i = 0; i < this.options.length; i++) {
          const weight = this.options[i].multiplier && this.options[i].multiplier > 0 
            ? this.options[i].multiplier 
            : 1;
          const arc = (2 * Math.PI) * (weight / totalWeight);
          
          if (normalized >= currentAngle && normalized < currentAngle + arc) {
            return i;
          }
          currentAngle += arc;
        }
        return 0;
      }

      getCurrentOption() {
        const index = this.getCurrentSegmentIndex();
        if (index === -1) return null;
        this.lastWinnerIndex = index;
        return this.options[index] || null;
      }

      /**
       * Retourne un index al√©atoire pond√©r√© par multiplier (x2, etc.).
       */
      getWeightedRandomIndex() {
        if (!this.options.length) return null;
        const weights = this.options.map((opt) =>
          opt && opt.multiplier && opt.multiplier > 0 ? opt.multiplier : 1
        );
        const total = weights.reduce((sum, w) => sum + w, 0);
        if (total <= 0) return 0;

        let r = Math.random() * total;
        for (let i = 0; i < weights.length; i++) {
          if (r < weights[i]) return i;
          r -= weights[i];
        }
        return 0;
      }

      /**
       * Lance un spin : la roue acc√©l√®re puis ralentit jusqu'√† s'arr√™ter sur une option.
       */
      spin() {
        if (this.isSpinning || !this.options.length) return;

        // on coupe l'auto-rotation lente pendant le spin
        this.isAutoRotating = false;
        this.isSpinning = true;

        // Jouer le son imm√©diatement au d√©marrage du spin
        if (this.tickSound) {
          this.tickSound.currentTime = 0;
          this.tickSound.play().catch(() => {
            // Ignorer les erreurs de lecture (autoplay policy)
          });
        }

        // Initialiser avec le segment actuel pour d√©tecter le prochain changement
        this.lastSegmentIndex = this.getCurrentSegmentIndex();

        const startAngle = this.rotationAngle;
        const n = this.options.length;
        const arc = (2 * Math.PI) / n;

        // Choix de l'index gagnant avec pond√©ration (x2)
        const targetIndex = this.getWeightedRandomIndex() ?? 0;

        // angle qui met le centre du segment gagnant sous l'aiguille
        const targetBaseAngle = (2 * Math.PI - (targetIndex + 0.5) * arc);
        const extraSpins = 4 + Math.random() * 3; // entre 4 et 7 tours complets
        const endAngle = targetBaseAngle + 2 * Math.PI * extraSpins;
        const totalDelta = endAngle - startAngle;
        const duration = 3000; // ms
        const startTime = performance.now();

        const animate = (now) => {
          const t = Math.min(1, (now - startTime) / duration);
          // easing "ease-out" pour un arr√™t en douceur
          const eased = 1 - Math.pow(1 - t, 3);
          this.rotationAngle = startAngle + totalDelta * eased;
          this.draw();

          // D√©tecter le changement de segment pour jouer le son
          const currentSegment = this.getCurrentSegmentIndex();
          if (currentSegment !== -1 && currentSegment !== this.lastSegmentIndex) {
            this.lastSegmentIndex = currentSegment;
            // Jouer le son d√®s qu'on d√©tecte un segment valide
            if (this.tickSound) {
              this.tickSound.currentTime = 0;
              this.tickSound.play().catch(() => {
                // Ignorer les erreurs de lecture (autoplay policy)
              });
            }
          }

          if (t < 1) {
            requestAnimationFrame(animate);
          } else {
            this.isSpinning = false;
            this.lastSegmentIndex = -1; // Reset pour le prochain spin
            const winner = this.getCurrentOption();
            if (typeof this.onSpinEnd === 'function') {
              this.onSpinEnd(winner);
            }
          }
        };

        requestAnimationFrame(animate);
      }

      startAutoRotate() {
        if (this.isAutoRotating) return;
        this.isAutoRotating = true;

        const step = () => {
          if (!this.isAutoRotating) return;
          this.rotationAngle += this.rotationSpeed;
          // √©vite que l'angle ne grossisse √† l'infini
          if (this.rotationAngle > Math.PI * 2) {
            this.rotationAngle -= Math.PI * 2;
          }
          // Incr√©menter le temps pour l'animation arc-en-ciel (plus rapide)
          this.rainbowTime += 0.03;
          this.draw();
          requestAnimationFrame(step);
        };

        requestAnimationFrame(step);
      }
    }

    /**
     * G√®re l'input pour ajouter des options √† la roue.
     */
    // ========================================
    // CLASSE OPTIONINPUTCONTROLLER
    // ========================================
    class OptionInputController {
      constructor(wheelInstance, inputId = 'entry-input') {
        this.wheel = wheelInstance;
        this.input = document.getElementById(inputId);
        
        if (this.input) {
          this.bindEvents();
        }
      }

      bindEvents() {
        this.input.addEventListener('keydown', (event) => {
          if (event.key !== 'Enter') return;

          const value = this.input.value.trim();
          if (!value) return;

          this.wheel.addOption(value);
          this.input.value = '';
        });
      }
    }

    /**
     * G√®re le slider de suspense pour dupliquer les options.
     */
    // ========================================
    // CLASSE SUSPENSESLIDERCONTROLLER
    // ========================================
    class SuspenseSliderController {
      constructor(wheelInstance) {
        this.wheel = wheelInstance;
        this.slider = document.getElementById('suspense-slider');
        this.valueDisplay = document.getElementById('suspense-value');
        
        if (this.slider && this.valueDisplay) {
          this.bindEvents();
        }
      }

      bindEvents() {
        this.slider.addEventListener('input', (event) => {
          const value = parseInt(event.target.value);
          this.valueDisplay.textContent = `x${value}`;
          this.wheel.setSuspenseMultiplier(value);
        });
      }
    }

    /**
     * G√®re le bouton de spin et l'affichage du r√©sultat.
     */
    // ========================================
    // CLASSE SPINCONTROLLER
    // ========================================
    class SpinController {
      constructor(wheelInstance) {
        this.wheel = wheelInstance;
        this.spinButton = document.getElementById('spin');
        this.resultContainer = document.getElementById('result');
        this.resultText = document.getElementById('result-text');
        this.resultClose = document.getElementById('result-close');
        this.resultRemove = document.getElementById('result-remove');

        if (this.spinButton && this.resultContainer && this.resultText) {
          this.init();
        }
      }

      init() {
        this.updateSpinButtonState();
        this.wheel.onOptionsChanged = () => this.updateSpinButtonState();
        this.bindEvents();
      }

      updateSpinButtonState() {
        const hasRealOptions = !this.wheel.usesDefaultOptions && this.wheel.options.length > 0;
        this.spinButton.disabled = !hasRealOptions;
      }

      bindEvents() {
        // Bouton de fermeture du modal r√©sultat
        if (this.resultClose) {
          this.resultClose.addEventListener('click', () => {
            this.hideResult();
          });
        }

        // Bouton pour retirer l'option gagnante de la liste
        if (this.resultRemove) {
          this.resultRemove.addEventListener('click', () => {
            if (typeof this.wheel.lastWinnerIndex === 'number') {
              this.wheel.removeOption(this.wheel.lastWinnerIndex);
              this.hideResult();
            }
          });
        }

        // Bouton de spin
        this.spinButton.addEventListener('click', () => {
          // D√©sactiver le bouton pendant le spin
          this.spinButton.disabled = true;
          this.wheel.onSpinEnd = (winner) => this.showResult(winner);
          this.wheel.spin();
        });
      }

      showResult(winner) {
        if (!winner) return;
        this.resultText.textContent = `ü•íüçëü§åüî• ${String(winner.text)} üî•ü§åüçëü•í`;
        this.resultContainer.classList.add('show');
        this.createConfetti();
        // D√©sactiver le bouton SPIN pendant l'affichage du r√©sultat
        this.spinButton.disabled = true;
      }

      createConfetti() {
        const { CONFETTI_COUNT, CONFETTI_COLORS } = ANIMATION_CONFIG;
        
        for (let i = 0; i < CONFETTI_COUNT; i++) {
          setTimeout(() => {
            const confetti = document.createElement('div');
            confetti.className = 'confetti confetti-animation';
            
            // Style du confetti
            Object.assign(confetti.style, {
              left: `${Math.random() * 100}%`,
              background: CONFETTI_COLORS[Math.floor(Math.random() * CONFETTI_COLORS.length)],
              width: `${Math.random() * 10 + 5}px`,
              height: `${Math.random() * 10 + 5}px`,
              borderRadius: Math.random() > 0.5 ? '50%' : '0',
              animationDuration: `${Math.random() * 3 + 2}s`,
              animationDelay: `${Math.random() * 0.3}s`
            });
            
            confetti.style.setProperty('--drift', `${(Math.random() - 0.5) * 200}px`);
            
            document.body.appendChild(confetti);
            
            // Nettoyage automatique
            setTimeout(() => confetti.remove(), 6000);
          }, i * 8);
        }
      }

      hideResult() {
        this.resultContainer.classList.remove('show');
        this.wheel.startAutoRotate();
        // R√©activer le bouton SPIN (v√©rifie automatiquement s'il y a des options valides)
        this.updateSpinButtonState();
      }
    }

    /**
     * G√®re la persistance et l'affichage des roues sauvegard√©es.
     */
    // ========================================
    // CLASSE SAVEDWHEELSMANAGER
    // ========================================
    class SavedWheelsManager {
      constructor(wheelInstance) {
        if (!wheelInstance) {
          throw new Error('Instance Wheel requise pour SavedWheelsManager');
        }

        this.wheel = wheelInstance;
        this.storageKey = STORAGE_KEYS.SAVED_WHEELS;
        
        // √âl√©ments DOM
        this.savedList = document.querySelector('.saved-wheels');
        this.saveBtn = document.getElementById('save-wheel');
        this.addNewBtn = document.getElementById('add-new-wheel');
        this.importBtn = document.getElementById('import-wheel');
        this.exportBtn = document.getElementById('export-wheel');
        
        // √âtat
        this.savedWheels = [];
        this.currentSavedId = null;
        this.templateItem = null;
        this.lastSavedState = null;

        if (this.savedList) {
          this.init();
        }
      }

      init() {
        // R√©cup√®re un template √† partir du premier item statique
        const existingItem = this.savedList.querySelector('.saved-wheel');
        if (existingItem) {
          this.templateItem = existingItem.cloneNode(true);
        }

        this.loadFromStorage();
        this.renderList();
        this.bindEvents();
        
        // V√©rifier s'il y a des modifications non sauvegard√©es apr√®s un reload
        this.checkUnsavedStateOnLoad();
      }

      /**
       * V√©rifie s'il y a un √©tat non sauvegard√© apr√®s un reload de page
       * Ne s'affiche QUE si une option avait √©t√© ajout√©e
       */
      checkUnsavedStateOnLoad() {
        const unsavedState = Utils.storage.get(STORAGE_KEYS.UNSAVED_STATE);
        
        // Seulement si un √©tat existe (c'est-√†-dire qu'une option avait √©t√© ajout√©e)
        if (unsavedState && unsavedState.options && unsavedState.options.length > 0) {
          // Afficher la modal pour proposer de sauvegarder
          setTimeout(() => {
            this.showUnsavedChangesModal(
              () => {
                // Sauvegarder les modifications
                this.wheel.setOptions(unsavedState.options);
                this.saveCurrentWheel();
                Utils.storage.set(STORAGE_KEYS.UNSAVED_STATE, null);
              },
              () => {
                // Ne pas sauvegarder, supprimer l'√©tat
                Utils.storage.set(STORAGE_KEYS.UNSAVED_STATE, null);
              }
            );
          }, 500);
        } else {
          // Pas d'√©tat sauvegard√©, nettoyer juste au cas o√π
          Utils.storage.set(STORAGE_KEYS.UNSAVED_STATE, null);
        }
      }

      /**
       * Sauvegarde l'√©tat actuel avant un reload (appel√© via beforeunload)
       * Uniquement si une nouvelle option a √©t√© ajout√©e
       */
      saveUnsavedState() {
        if (this.wheel.hasAddedNewOption && this.hasUnsavedChanges() && !this.wheel.usesDefaultOptions) {
          const state = {
            options: this.wheel.baseOptions,
            isDefault: this.wheel.usesDefaultOptions,
            timestamp: Date.now()
          };
          Utils.storage.set(STORAGE_KEYS.UNSAVED_STATE, state);
        }
      }

      loadFromStorage() {
        const wheels = Utils.storage.get(this.storageKey, []);
        if (Array.isArray(wheels)) {
          this.savedWheels = wheels;
        }
      }

      saveToStorage() {
        Utils.storage.set(this.storageKey, this.savedWheels);
      }

      getNextWheelNumber() {
        let maxNum = 0;
        this.savedWheels.forEach((w) => {
          const match = w.name && w.name.match(/^Roue (\d+)$/);
          if (match) {
            const num = parseInt(match[1], 10);
            if (num > maxNum) maxNum = num;
          }
        });
        return maxNum + 1;
      }

      createWheelSnapshot() {
        const id = this.currentSavedId || Date.now();
        let name;
        
        if (this.currentSavedId) {
          // Si on modifie une roue existante, garder son nom
          const existing = this.savedWheels.find((w) => w.id === this.currentSavedId);
          name = existing ? existing.name : `Roue ${this.getNextWheelNumber()}`;
        } else {
          // Nouvelle roue : nom incr√©mental
          name = `Roue ${this.getNextWheelNumber()}`;
        }

        return {
          id,
          name,
          options: this.wheel.options.map((opt) => ({
            text: opt.text,
            boosted: !!opt.boosted,
            multiplier: opt.multiplier && opt.multiplier > 0 ? opt.multiplier : 1,
          })),
        };
      }

      renderList() {
        this.savedList.innerHTML = '';
        if (!this.templateItem) return;

        this.savedWheels.forEach((wheelData) => {
          const li = this.createWheelListItem(wheelData);
          this.savedList.appendChild(li);
        });
      }

      createWheelListItem(wheelData) {
        const li = this.templateItem.cloneNode(true);
        li.dataset.wheelId = wheelData.id;
        
        const nameSpan = li.querySelector('.saved-wheel-name');
        if (nameSpan) {
          nameSpan.textContent = wheelData.name || 'Roue';
          nameSpan.oninput = null;
          nameSpan.addEventListener('input', () => {
            wheelData.name = nameSpan.textContent.trim() || 'Roue';
            this.saveToStorage();
          });
        }

        const [loadBtn, deleteBtn] = li.querySelectorAll('.saved-wheel-btn.btn-little');

        if (loadBtn) {
          loadBtn.onclick = null;
          loadBtn.addEventListener('click', () => this.loadWheel(wheelData));
        }

        if (deleteBtn) {
          deleteBtn.onclick = null;
          deleteBtn.addEventListener('click', () => this.deleteWheel(wheelData.id));
        }

        return li;
      }

      hasUnsavedChanges() {
        if (!this.lastSavedState) return false;
        
        const currentState = JSON.stringify({
          options: this.wheel.options.map((opt) => ({
            text: opt.text,
            boosted: !!opt.boosted,
            multiplier: opt.multiplier || 1,
          })),
        });
        
        return currentState !== this.lastSavedState;
      }

      updateLastSavedState() {
        this.lastSavedState = JSON.stringify({
          options: this.wheel.options.map((opt) => ({
            text: opt.text,
            boosted: !!opt.boosted,
            multiplier: opt.multiplier || 1,
          })),
        });
      }

      showUnsavedChangesModal(onSave, onDiscard) {
        const modal = document.getElementById('unsaved-changes-modal');
        const saveBtn = document.getElementById('modal-save-btn');
        const discardBtn = document.getElementById('modal-discard-btn');
        const cancelBtn = document.getElementById('modal-cancel-btn');

        if (!modal) return;

        // Fonction pour fermer la modal
        const closeModal = () => {
          modal.classList.remove('show');
          setTimeout(() => {
            modal.style.display = 'none';
          }, 300);
        };

        // Gestionnaires d'√©v√©nements
        const handleSave = () => {
          closeModal();
          onSave();
        };

        const handleDiscard = () => {
          closeModal();
          onDiscard();
        };

        const handleCancel = () => {
          closeModal();
        };

        // Nettoyer les anciens listeners (cloner pour supprimer tous les listeners)
        const newSaveBtn = saveBtn.cloneNode(true);
        const newDiscardBtn = discardBtn.cloneNode(true);
        const newCancelBtn = cancelBtn.cloneNode(true);
        
        saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);
        discardBtn.parentNode.replaceChild(newDiscardBtn, discardBtn);
        cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);

        // Attacher les nouveaux listeners
        newSaveBtn.addEventListener('click', handleSave);
        newDiscardBtn.addEventListener('click', handleDiscard);
        newCancelBtn.addEventListener('click', handleCancel);

        // Afficher la modal avec animation
        modal.style.display = 'flex';
        setTimeout(() => modal.classList.add('show'), 10);
      }

      loadWheel(wheelData) {
        if (this.hasUnsavedChanges()) {
          this.showUnsavedChangesModal(
            () => {
              // Sauvegarder puis charger
              this.saveCurrentWheel();
              this.performLoadWheel(wheelData);
            },
            () => {
              // Ne pas sauvegarder, charger directement
              this.performLoadWheel(wheelData);
            }
          );
        } else {
          this.performLoadWheel(wheelData);
        }
      }

      resetSuspenseSlider() {
        const slider = document.getElementById('suspense-slider');
        const valueDisplay = document.getElementById('suspense-value');
        
        if (slider) {
          slider.value = 1;
        }
        if (valueDisplay) {
          valueDisplay.textContent = 'x1';
        }
        // R√©initialiser le multiplicateur de suspense dans la roue
        this.wheel.setSuspenseMultiplier(1);
      }

      performLoadWheel(wheelData) {
        this.currentSavedId = wheelData.id;
        this.wheel.usesDefaultOptions = false;
        this.wheel.setOptions(wheelData.options || []);
        // R√©initialiser le slider √† 1 pour chaque nouvelle roue charg√©e
        this.resetSuspenseSlider();
        this.updateLastSavedState();
        // R√©initialiser le flag d'ajout de nouvelle option
        this.wheel.hasAddedNewOption = false;
      }

      deleteWheel(wheelId) {
        this.savedWheels = this.savedWheels.filter((w) => w.id !== wheelId);
        if (this.currentSavedId === wheelId) {
          this.currentSavedId = null;
        }
        this.saveToStorage();
        this.renderList();
      }

      saveCurrentWheel() {
        const snapshot = this.createWheelSnapshot();
        const existingIndex = this.savedWheels.findIndex((w) => w.id === this.currentSavedId);
        
        if (existingIndex >= 0) {
          // Mise √† jour d'une roue existante
          this.savedWheels[existingIndex] = snapshot;
        } else {
          // Cr√©ation d'une nouvelle entr√©e (si liste vide ou aucune roue s√©lectionn√©e)
          if (this.savedWheels.length === 0 || !this.currentSavedId) {
            this.savedWheels.push(snapshot);
            this.currentSavedId = snapshot.id;
          } else {
            // Il y a des roues mais aucune n'est s√©lectionn√©e
            this.showNotification('Aucune roue s√©lectionn√©e. Cliquez sur une roue dans la liste ou utilisez "START A NEW WHEEL".', true);
            return;
          }
        }
        
        this.saveToStorage();
        this.renderList();
        this.updateLastSavedState();
        this.showNotification('Roue sauvegard√©e ! üíæ');
        
        // R√©initialiser le flag d'ajout de nouvelle option
        this.wheel.hasAddedNewOption = false;
      }

      addNewWheel() {
        if (this.hasUnsavedChanges()) {
          this.showUnsavedChangesModal(
            () => {
              // Sauvegarder puis cr√©er nouvelle roue
              this.saveCurrentWheel();
              this.performAddNewWheel();
            },
            () => {
              // Ne pas sauvegarder, cr√©er nouvelle roue directement
              this.performAddNewWheel();
            }
          );
        } else {
          this.performAddNewWheel();
        }
      }

      performAddNewWheel() {
        // Cr√©er un nouvel item dans la liste avec les options par d√©faut (DRAMAS)
        const newWheelId = Date.now();
        const newWheel = {
          id: newWheelId,
          name: `Roue ${this.getNextWheelNumber()}`,
          options: this.wheel.defaultOptions.map((opt) => ({
            text: typeof opt === 'string' ? opt : opt.text,
            boosted: false,
            multiplier: 1,
          })),
        };

        this.savedWheels.push(newWheel);
        this.currentSavedId = newWheelId;
        this.saveToStorage();
        this.renderList();

        // Charger cette nouvelle roue (√©tat par d√©faut DRAMAS)
        // Cacher le slider AVANT de charger les options pour √©viter qu'il apparaisse bri√®vement
        const sliderContainer = document.getElementById('suspense-slider-container');
        if (sliderContainer) {
          sliderContainer.style.display = 'none';
        }
        
        this.wheel.usesDefaultOptions = true;
        this.wheel.setOptions(newWheel.options);
        // R√©initialiser le slider √† 1 pour chaque nouvelle roue cr√©√©e
        this.resetSuspenseSlider();
        // S'assurer que le slider de suspense est bien cach√© pour les options par d√©faut
        this.wheel.updateSuspenseSliderVisibility();
        this.updateLastSavedState();
        // R√©initialiser le flag d'ajout de nouvelle option
        this.wheel.hasAddedNewOption = false;
      }

      async exportWheel() {
        try {
          // Cr√©er un snapshot de la roue actuelle
          const wheelData = {
            name: this.currentSavedId 
              ? this.savedWheels.find((w) => w.id === this.currentSavedId)?.name || 'Roue export√©e'
              : 'Roue export√©e',
            options: this.wheel.options.map((opt) => ({
              text: opt.text,
              boosted: !!opt.boosted,
              multiplier: opt.multiplier && opt.multiplier > 0 ? opt.multiplier : 1,
            })),
          };

          const json = JSON.stringify(wheelData, null, 2);
          
          // Copier dans le presse-papier
          await navigator.clipboard.writeText(json);
          
          // Notification visuelle
          this.showNotification('Roue export√©e dans le presse-papier ! üìã');
        } catch (e) {
          console.error('Erreur lors de l\'export :', e);
          this.showNotification('Erreur lors de l\'export ‚ùå', true);
        }
      }

      async importWheel() {
        try {
          // Lire depuis le presse-papier
          const clipboardText = await navigator.clipboard.readText();
          
          if (!clipboardText) {
            this.showNotification('Presse-papier vide ‚ùå', true);
            return;
          }

          // Parser le JSON
          const wheelData = JSON.parse(clipboardText);
          
          // Valider la structure
          if (!wheelData.options || !Array.isArray(wheelData.options)) {
            this.showNotification('Format invalide ‚ùå', true);
            return;
          }

          // D√©terminer le nom de la roue import√©e
          let wheelName;
          if (wheelData.name) {
            // V√©rifier si le nom existe d√©j√†
            const nameExists = this.savedWheels.some((w) => w.name === wheelData.name);
            if (nameExists) {
              // Si le nom existe, utiliser l'incr√©mentation
              wheelName = `Roue ${this.getNextWheelNumber()}`;
            } else {
              // Sinon, utiliser le nom import√©
              wheelName = wheelData.name;
            }
          } else {
            // Pas de nom fourni, utiliser l'incr√©mentation
            wheelName = `Roue ${this.getNextWheelNumber()}`;
          }

          // Cr√©er une nouvelle entr√©e dans la liste
          const newWheelId = Date.now();
          const newWheel = {
            id: newWheelId,
            name: wheelName,
            options: wheelData.options.map((opt) => ({
              text: opt.text || '',
              boosted: !!opt.boosted,
              multiplier: opt.multiplier && opt.multiplier > 0 ? opt.multiplier : 1,
            })),
          };

          this.savedWheels.push(newWheel);
          this.saveToStorage();
          this.renderList();

          // Charger la roue import√©e
          this.currentSavedId = newWheelId;
          this.wheel.usesDefaultOptions = false;
          this.wheel.setOptions(newWheel.options);
          // R√©initialiser le slider √† 1 pour chaque roue import√©e
          this.resetSuspenseSlider();
          this.updateLastSavedState();

          this.showNotification('Roue import√©e avec succ√®s ! ‚úÖ');
        } catch (e) {
          console.error('Erreur lors de l\'import :', e);
          this.showNotification('Erreur lors de l\'import (JSON invalide ?) ‚ùå', true);
        }
      }

      showNotification(message, isError = false) {
        const notification = document.createElement('div');
        notification.textContent = message;
        notification.style.cssText = `
          position: fixed;
          top: 20px;
          left: 50%;
          transform: translateX(-50%);
          background: ${isError ? '#f496ad' : '#e3b9ff'};
          color: white;
          padding: 15px 30px;
          border-radius: 12px;
          border: 3px solid rgba(255, 255, 255, 0.5);
          font-size: 16px;
          font-weight: 600;
          z-index: 10001;
          box-shadow: 0 4px 12px rgba(203, 97, 163, 0.4);
          animation: slideDown 0.3s ease-out;
        `;

        // Animation CSS
        const style = document.createElement('style');
        style.textContent = `
          @keyframes slideDown {
            from {
              opacity: 0;
              transform: translateX(-50%) translateY(-20px);
            }
            to {
              opacity: 1;
              transform: translateX(-50%) translateY(0);
            }
          }
        `;
        document.head.appendChild(style);

        document.body.appendChild(notification);

        // Supprimer apr√®s 3 secondes
        setTimeout(() => {
          notification.style.opacity = '0';
          notification.style.transition = 'opacity 0.3s';
          setTimeout(() => {
            document.body.removeChild(notification);
            document.head.removeChild(style);
          }, 300);
        }, 3000);
      }

      bindEvents() {
        if (this.saveBtn) {
          this.saveBtn.addEventListener('click', () => this.saveCurrentWheel());
        }

        if (this.addNewBtn) {
          this.addNewBtn.addEventListener('click', () => this.addNewWheel());
        }

        // Boutons Import/Export
        const importBtn = document.getElementById('import-wheel');
        const exportBtn = document.getElementById('export-wheel');

        if (importBtn) {
          importBtn.addEventListener('click', () => this.importWheel());
        }

        if (exportBtn) {
          exportBtn.addEventListener('click', () => this.exportWheel());
        }

        // Sauvegarder l'√©tat avant un reload/fermeture de page
        window.addEventListener('beforeunload', () => {
          this.saveUnsavedState();
        });
      }
    }

    /**
     * Point d'entr√©e principal de l'application.
     */
    // ========================================
    // CLASSE WHEELAPP (ORCHESTRATEUR)
    // ========================================
    class WheelApp {
      constructor() {
        this.canvas = document.getElementById('wheel');
        this.defaultOptions = ['D', 'R', 'A', 'M', 'A', 'S'];
        
        if (this.canvas) {
          this.init();
        }
      }

      init() {
        this.setupCanvas();
        this.createWheel();
        this.createControllers();
      }

      setupCanvas() {
        const displayWidth = this.canvas.clientWidth || 
          (this.canvas.parentElement && this.canvas.parentElement.clientWidth) || 500;
        const displayHeight = this.canvas.clientHeight || 
          (this.canvas.parentElement && this.canvas.parentElement.clientHeight) || 500;
        this.canvas.width = displayWidth;
        this.canvas.height = displayHeight;
      }

      createWheel() {
        // true => ces options sont consid√©r√©es comme "par d√©faut"
        this.wheel = new Wheel(this.canvas, this.defaultOptions, true);
        this.wheel.draw();
        this.wheel.startAutoRotate(); // rotation lente par d√©faut

        // Synchronise les options avec la liste du panneau droit
        const optionsList = document.querySelector('.wheel-options-list');
        if (optionsList) {
          this.wheel.attachOptionsList(optionsList);
        }
      }

      createControllers() {
        // Initialise tous les contr√¥leurs
        this.optionInputController = new OptionInputController(this.wheel);
        this.suspenseSliderController = new SuspenseSliderController(this.wheel);
        this.spinController = new SpinController(this.wheel);
        this.savedWheelsManager = new SavedWheelsManager(this.wheel);
      }
    }

    /**
     * G√®re le background al√©atoire avec mise en cache et chargement optimis√©.
     */
    // ========================================
    // CLASSE BACKGROUNDMANAGER
    // ========================================
    class BackgroundManager {
      constructor() {
        this.storageKey = STORAGE_KEYS.LAST_BACKGROUND;
        this.storageTitleKey = STORAGE_KEYS.LAST_TITLE;
        
        // Chaque background est associ√© √† son titre correspondant
        // Extensions des backgrounds (certains sont .jpeg, d'autres .png)
        const bgExtensions = {
          5: 'jpeg', 12: 'jpeg', 13: 'jpeg', 14: 'jpeg', 15: 'jpeg',
          16: 'jpeg', 17: 'jpeg', 19: 'jpeg', 20: 'jpeg', 22: 'jpeg'
        };
        
        this.backgrounds = Array.from({ length: 24 }, (_, idx) => {
          const i = idx + 1;
          const bgExt = bgExtensions[i] || 'png';
          return {
            bg: `asset/images/backgrounds/${i}.${bgExt}`,
            title: `asset/images/titles/${i}.png`,
          };
        });
        
        this.init();
      }

      init() {
        const appLayout = document.querySelector('.app-layout');
        const wheelTitle = document.querySelector('.wheel-title');
        if (!appLayout) return;

        // R√©cup√©rer et afficher imm√©diatement le background et titre pr√©c√©dents s'ils existent
        const lastBg = this.getLastBackground();
        const lastTitle = this.getLastTitle();
        if (lastBg) {
          appLayout.style.backgroundImage = `url('${lastBg}')`;
        } else {
          // Premi√®re visite : couleur de fond
          appLayout.classList.add('loading');
        }
        if (lastTitle && wheelTitle) {
          wheelTitle.innerHTML = `<img src="${lastTitle}" alt="Titre">`;
        }

        // Choisir un nouveau background al√©atoire √† chaque rechargement
        const randomIndex = Math.floor(Math.random() * this.backgrounds.length);
        const selected = this.backgrounds[randomIndex];
        
        // Sauvegarder pour la prochaine fois
        this.saveLastBackground(selected.bg);
        this.saveLastTitle(selected.title);
        
        // Charger et appliquer avec transition douce
        this.loadBackgroundWithTransition(selected.bg, selected.title);
      }

      getLastBackground() {
        return Utils.storage.getString(this.storageKey);
      }

      getLastTitle() {
        return Utils.storage.getString(this.storageTitleKey);
      }

      saveLastBackground(url) {
        Utils.storage.setString(this.storageKey, url);
      }

      saveLastTitle(url) {
        Utils.storage.setString(this.storageTitleKey, url);
      }

      loadBackgroundWithTransition(bgUrl, titleUrl) {
        const appLayout = document.querySelector('.app-layout');
        const wheelTitle = document.querySelector('.wheel-title');
        if (!appLayout) return;

        // Images locales : transition simple avec fondu
        appLayout.style.transition = 'opacity 0.4s ease-in-out';
        appLayout.style.opacity = '0.7';
        
        setTimeout(() => {
          appLayout.style.backgroundImage = `url('${bgUrl}')`;
          appLayout.classList.remove('loading');
          
          if (wheelTitle && titleUrl) {
            wheelTitle.innerHTML = `<img src="${titleUrl}" alt="Titre">`;
          }
          
          setTimeout(() => {
            appLayout.style.opacity = '1';
            setTimeout(() => appLayout.style.transition = '', 400);
          }, 50);
        }, 400);
      }
    }

    /**
     * G√®re le mode plein √©cran
     */
    // ========================================
    // CLASSE FULLSCREENMANAGER
    // ========================================
    class FullscreenManager {
      constructor() {
        this.isFullscreen = false;
        this.appLayout = document.querySelector('.app-layout');
        this.toggleBtn = document.getElementById('fullscreen-toggle');
        
        if (this.toggleBtn) {
          this.toggleBtn.addEventListener('click', () => this.toggle());
        }
      }

      toggle() {
        this.isFullscreen = !this.isFullscreen;
        
        if (this.isFullscreen) {
          this.appLayout.classList.add('fullscreen-mode');
          this.toggleBtn.textContent = '‚úï';
          this.toggleBtn.title = 'Quitter le plein √©cran';
        } else {
          this.appLayout.classList.remove('fullscreen-mode');
          this.toggleBtn.textContent = '‚õ∂';
          this.toggleBtn.title = 'Mode plein √©cran';
        }
      }
    }

    /**
     * G√®re le menu mobile pour le left-panel
     */
    // ========================================
    // CLASSE MOBILEMENUMANAGER
    // ========================================
    class MobileMenuManager {
      constructor() {
        this.menuBtn = document.getElementById('mobile-menu-btn');
        this.overlay = document.getElementById('mobile-menu-overlay');
        this.leftPanel = document.querySelector('.left-panel');
        
        if (this.menuBtn && this.overlay && this.leftPanel) {
          this.menuBtn.addEventListener('click', () => this.open());
          this.overlay.addEventListener('click', () => this.close());
        }
      }

      open() {
        this.leftPanel.classList.add('open');
        this.overlay.classList.add('active');
      }

      close() {
        this.leftPanel.classList.remove('open');
        this.overlay.classList.remove('active');
      }
    }

    /**
     * G√®re l'ouverture/fermeture du panel de notes
     */
    // ========================================
    // CLASSE NOTEPANELMANAGER
    // ========================================
    class NotePanelManager {
      constructor() {
        this.noteTab = document.getElementById('note-tab');
        this.sideNote = document.getElementById('side-note');
        this.overlay = document.getElementById('side-note-overlay');
        this.closeBtn = document.getElementById('side-note-close');
        this.isOpen = false;
        
        if (this.noteTab && this.sideNote) {
          this.noteTab.addEventListener('click', () => this.toggle());
          
          if (this.closeBtn) {
            this.closeBtn.addEventListener('click', () => this.close());
            this.closeBtn.addEventListener('mousedown', (e) => {
              e.target.style.transform = 'scale(0.85)';
            });
            this.closeBtn.addEventListener('mouseup', (e) => {
              e.target.style.transform = 'scale(1)';
            });
          }
          
          // Fermer en cliquant sur l'overlay
          if (this.overlay) {
            this.overlay.addEventListener('click', () => this.close());
          }
          
          // Emp√™cher la fermeture quand on clique dans le panel
          this.sideNote.addEventListener('click', (e) => {
            e.stopPropagation();
          });
          
        }
      }

      toggle() {
        if (this.isOpen) {
          this.close();
        } else {
          this.open();
        }
      }

      open() {
        this.sideNote.classList.add('open');
        if (this.overlay) {
          this.overlay.classList.add('active');
        }
        this.isOpen = true;
      }

      close() {
        this.sideNote.classList.remove('open');
        if (this.overlay) {
          this.overlay.classList.remove('active');
        }
        this.isOpen = false;
      }

    }

    // D√©marrage de l'application
    document.addEventListener('DOMContentLoaded', () => {
      new BackgroundManager();
      new WheelApp();
      new FullscreenManager();
      new NotePanelManager();
      new MobileMenuManager();
    });
